<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc -->
<title>ListenableFutureTask (threadly 7.0 API)</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../jquery/jquery-ui.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
<script type="text/javascript" src="../../../../jquery/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../../../../jquery/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../../../../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../../../../jquery/jquery-3.5.1.js"></script>
<script type="text/javascript" src="../../../../jquery/jquery-ui.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="ListenableFutureTask (threadly 7.0 API)";
        }
    }
    catch(err) {
    }
//-->
var data = {"i0":10,"i1":10,"i2":10,"i3":10,"i4":10,"i5":10,"i6":10,"i7":10,"i8":10,"i9":10,"i10":10,"i11":10,"i12":10,"i13":10,"i14":10,"i15":10,"i16":10,"i17":10,"i18":10,"i19":10,"i20":10,"i21":10,"i22":10};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../../../";
var useModuleDirectories = true;
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<div class="fixedNav">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<ul class="navListSearch">
<li><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
</div>
<div class="navPadding">&nbsp;</div>
<script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script>
</nav>
</header>
<!-- ======== START OF CLASS DATA ======== -->
<main role="main">
<div class="header">
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="package-summary.html">org.threadly.concurrent.future</a></div>
<h2 title="Class ListenableFutureTask" class="title">Class ListenableFutureTask&lt;T&gt;</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>org.threadly.concurrent.future.ListenableFutureTask&lt;T&gt;</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - The result object type returned by this future</dd>
</dl>
<dl>
<dt>All Implemented Interfaces:</dt>
<dd><code>java.lang.Runnable</code>, <code>java.util.concurrent.Future&lt;T&gt;</code>, <code>java.util.concurrent.RunnableFuture&lt;T&gt;</code>, <code><a href="../CallableContainer.html" title="interface in org.threadly.concurrent">CallableContainer</a>&lt;T&gt;</code>, <code><a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;T&gt;</code>, <code><a href="ListenableRunnableFuture.html" title="interface in org.threadly.concurrent.future">ListenableRunnableFuture</a>&lt;T&gt;</code></dd>
</dl>
<dl>
<dt>Direct Known Subclasses:</dt>
<dd><code><a href="ExecuteOnGetFutureTask.html" title="class in org.threadly.concurrent.future">ExecuteOnGetFutureTask</a></code>, <code><a href="ListenableFutureAdapterTask.html" title="class in org.threadly.concurrent.future">ListenableFutureAdapterTask</a></code></dd>
</dl>
<hr>
<pre>public class <span class="typeNameLabel">ListenableFutureTask&lt;T&gt;</span>
extends java.lang.Object
implements <a href="ListenableRunnableFuture.html" title="interface in org.threadly.concurrent.future">ListenableRunnableFuture</a>&lt;T&gt;, <a href="../CallableContainer.html" title="interface in org.threadly.concurrent">CallableContainer</a>&lt;T&gt;</pre>
<div class="block">This is a future which can be executed.  Allowing you to construct the future with the interior 
 work, submit it to an <code>Executor</code>, and then return this future.</div>
<dl>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>1.0.0</dd>
</dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== NESTED CLASS SUMMARY ======== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="nested.class.summary">
<!--   -->
</a>
<h3>Nested Class Summary</h3>
<ul class="blockList">
<li class="blockList"><a id="nested.classes.inherited.from.class.org.threadly.concurrent.future.ListenableFuture">
<!--   -->
</a>
<h3>Nested classes/interfaces inherited from interface&nbsp;org.threadly.concurrent.future.<a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a></h3>
<code><a href="ListenableFuture.ListenerOptimizationStrategy.html" title="enum in org.threadly.concurrent.future">ListenableFuture.ListenerOptimizationStrategy</a></code></li>
</ul>
</li>
</ul>
</section>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="constructor.summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="memberSummary">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Constructor</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr class="altColor">
<th class="colConstructorName" scope="row"><code><span class="memberNameLink"><a href="#%3Cinit%3E(java.lang.Runnable)">ListenableFutureTask</a></span>&#8203;(java.lang.Runnable&nbsp;task)</code></th>
<td class="colLast">
<div class="block">Constructs a runnable future with a runnable work unit.</div>
</td>
</tr>
<tr class="rowColor">
<th class="colConstructorName" scope="row"><code><span class="memberNameLink"><a href="#%3Cinit%3E(java.lang.Runnable,T)">ListenableFutureTask</a></span>&#8203;(java.lang.Runnable&nbsp;task,
                    <a href="ListenableFutureTask.html" title="type parameter in ListenableFutureTask">T</a>&nbsp;result)</code></th>
<td class="colLast">
<div class="block">Constructs a runnable future with a runnable work unit.</div>
</td>
</tr>
<tr class="altColor">
<th class="colConstructorName" scope="row"><code><span class="memberNameLink"><a href="#%3Cinit%3E(java.lang.Runnable,T,java.util.concurrent.Executor)">ListenableFutureTask</a></span>&#8203;(java.lang.Runnable&nbsp;task,
                    <a href="ListenableFutureTask.html" title="type parameter in ListenableFutureTask">T</a>&nbsp;result,
                    java.util.concurrent.Executor&nbsp;executingExecutor)</code></th>
<td class="colLast">
<div class="block">Constructs a runnable future with a runnable work unit.</div>
</td>
</tr>
<tr class="rowColor">
<th class="colConstructorName" scope="row"><code><span class="memberNameLink"><a href="#%3Cinit%3E(java.util.concurrent.Callable)">ListenableFutureTask</a></span>&#8203;(java.util.concurrent.Callable&lt;<a href="ListenableFutureTask.html" title="type parameter in ListenableFutureTask">T</a>&gt;&nbsp;task)</code></th>
<td class="colLast">
<div class="block">Constructs a runnable future with a callable work unit.</div>
</td>
</tr>
<tr class="altColor">
<th class="colConstructorName" scope="row"><code><span class="memberNameLink"><a href="#%3Cinit%3E(java.util.concurrent.Callable,java.util.concurrent.Executor)">ListenableFutureTask</a></span>&#8203;(java.util.concurrent.Callable&lt;<a href="ListenableFutureTask.html" title="type parameter in ListenableFutureTask">T</a>&gt;&nbsp;task,
                    java.util.concurrent.Executor&nbsp;executingExecutor)</code></th>
<td class="colLast">
<div class="block">Constructs a runnable future with a callable work unit.</div>
</td>
</tr>
</table>
</li>
</ul>
</section>
<!-- ========== METHOD SUMMARY =========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Method</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code><a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#callback(org.threadly.concurrent.future.FutureCallback,java.util.concurrent.Executor,org.threadly.concurrent.future.ListenableFuture.ListenerOptimizationStrategy)">callback</a></span>&#8203;(<a href="FutureCallback.html" title="interface in org.threadly.concurrent.future">FutureCallback</a>&lt;? super T&gt;&nbsp;callback,
        java.util.concurrent.Executor&nbsp;executor,
        <a href="ListenableFuture.ListenerOptimizationStrategy.html" title="enum in org.threadly.concurrent.future">ListenableFuture.ListenerOptimizationStrategy</a>&nbsp;optimize)</code></th>
<td class="colLast">
<div class="block">Add a <a href="FutureCallback.html" title="interface in org.threadly.concurrent.future"><code>FutureCallback</code></a> to be called once the future has completed.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#cancel(boolean)">cancel</a></span>&#8203;(boolean&nbsp;interrupt)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#clearResult()">clearResult</a></span>()</code></th>
<td class="colLast">
<div class="block">Clears the stored result from this set future.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code><a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#failureCallback(java.util.function.Consumer,java.util.concurrent.Executor,org.threadly.concurrent.future.ListenableFuture.ListenerOptimizationStrategy)">failureCallback</a></span>&#8203;(java.util.function.Consumer&lt;java.lang.Throwable&gt;&nbsp;callback,
               java.util.concurrent.Executor&nbsp;executor,
               <a href="ListenableFuture.ListenerOptimizationStrategy.html" title="enum in org.threadly.concurrent.future">ListenableFuture.ListenerOptimizationStrategy</a>&nbsp;optimize)</code></th>
<td class="colLast">
<div class="block">Add a <code>Consumer</code> to be called once the future has completed.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>&lt;TT extends java.lang.Throwable&gt;<br><a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#flatMapFailure(java.lang.Class,java.util.function.Function)">flatMapFailure</a></span>&#8203;(java.lang.Class&lt;TT&gt;&nbsp;throwableType,
              java.util.function.Function&lt;? super TT,&#8203;<a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;T&gt;&gt;&nbsp;mapper)</code></th>
<td class="colLast">
<div class="block">Similar to <a href="ListenableFuture.html#mapFailure(java.lang.Class,java.util.function.Function)"><code>ListenableFuture.mapFailure(Class, Function)</code></a> except that this mapper function returns a 
 <a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future"><code>ListenableFuture</code></a> if it needs to map the Throwable / failure into a result or another 
 failure.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>&lt;TT extends java.lang.Throwable&gt;<br><a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#flatMapFailure(java.lang.Class,java.util.function.Function,java.util.concurrent.Executor)">flatMapFailure</a></span>&#8203;(java.lang.Class&lt;TT&gt;&nbsp;throwableType,
              java.util.function.Function&lt;? super TT,&#8203;<a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;T&gt;&gt;&nbsp;mapper,
              java.util.concurrent.Executor&nbsp;executor)</code></th>
<td class="colLast">
<div class="block">Similar to <a href="ListenableFuture.html#mapFailure(java.lang.Class,java.util.function.Function,java.util.concurrent.Executor)"><code>ListenableFuture.mapFailure(Class, Function, Executor)</code></a> except that this mapper function 
 returns a <a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future"><code>ListenableFuture</code></a> if it needs to map the Throwable / failure into a result 
 or another failure.</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>&lt;TT extends java.lang.Throwable&gt;<br><a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#flatMapFailure(java.lang.Class,java.util.function.Function,java.util.concurrent.Executor,org.threadly.concurrent.future.ListenableFuture.ListenerOptimizationStrategy)">flatMapFailure</a></span>&#8203;(java.lang.Class&lt;TT&gt;&nbsp;throwableType,
              java.util.function.Function&lt;? super TT,&#8203;<a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;T&gt;&gt;&nbsp;mapper,
              java.util.concurrent.Executor&nbsp;executor,
              <a href="ListenableFuture.ListenerOptimizationStrategy.html" title="enum in org.threadly.concurrent.future">ListenableFuture.ListenerOptimizationStrategy</a>&nbsp;optimizeExecution)</code></th>
<td class="colLast">
<div class="block">Similar to <a href="ListenableFuture.html#mapFailure(java.lang.Class,java.util.function.Function,java.util.concurrent.Executor,org.threadly.concurrent.future.ListenableFuture.ListenerOptimizationStrategy)"><code>ListenableFuture.mapFailure(Class, Function, Executor, ListenerOptimizationStrategy)</code></a> except 
 that this mapper function returns a <a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future"><code>ListenableFuture</code></a> if it needs to map the Throwable 
 into a result or another failure.</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>T</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#get()">get</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>T</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#get(long,java.util.concurrent.TimeUnit)">get</a></span>&#8203;(long&nbsp;timeout,
   java.util.concurrent.TimeUnit&nbsp;unit)</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>java.util.concurrent.Callable&lt;<a href="ListenableFutureTask.html" title="type parameter in ListenableFutureTask">T</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getContainedCallable()">getContainedCallable</a></span>()</code></th>
<td class="colLast">
<div class="block">Call to get the contained callable held within the wrapper.</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code>java.lang.Throwable</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getFailure()">getFailure</a></span>()</code></th>
<td class="colLast">
<div class="block">Similar to <code>Future.get()</code> except instead of providing a result, this will provide a thrown 
 exception if <a href="ListenableFuture.html#isCompletedExceptionally()"><code>ListenableFuture.isCompletedExceptionally()</code></a> returns <code>true</code>.</div>
</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code>java.lang.Throwable</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getFailure(long,java.util.concurrent.TimeUnit)">getFailure</a></span>&#8203;(long&nbsp;timeout,
          java.util.concurrent.TimeUnit&nbsp;unit)</code></th>
<td class="colLast">
<div class="block">Similar to <code>Future.get(long, TimeUnit)</code> except instead of providing a result, this will 
 provide a thrown exception if <a href="ListenableFuture.html#isCompletedExceptionally()"><code>ListenableFuture.isCompletedExceptionally()</code></a> returns <code>true</code>.</div>
</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code>java.lang.StackTraceElement[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getRunningStackTrace()">getRunningStackTrace</a></span>()</code></th>
<td class="colLast">
<div class="block">A best effort to return the stack trace for for the executing thread of either this future, 
 or a future which this depends on through the use of <a href="ListenableFuture.html#map(java.util.function.Function)"><code>ListenableFuture.map(Function)</code></a> or similar 
 functions.</div>
</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isCancelled()">isCancelled</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i14" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isCompletedExceptionally()">isCompletedExceptionally</a></span>()</code></th>
<td class="colLast">
<div class="block">Returns <code>true</code> if the future is both done and has completed with an error or was 
 canceled.</div>
</td>
</tr>
<tr id="i15" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isDone()">isDone</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i16" class="altColor">
<td class="colFirst"><code><a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#listener(java.lang.Runnable,java.util.concurrent.Executor,org.threadly.concurrent.future.ListenableFuture.ListenerOptimizationStrategy)">listener</a></span>&#8203;(java.lang.Runnable&nbsp;listener,
        java.util.concurrent.Executor&nbsp;executor,
        <a href="ListenableFuture.ListenerOptimizationStrategy.html" title="enum in org.threadly.concurrent.future">ListenableFuture.ListenerOptimizationStrategy</a>&nbsp;optimize)</code></th>
<td class="colLast">
<div class="block">Add a listener to be called once the future has completed.</div>
</td>
</tr>
<tr id="i17" class="rowColor">
<td class="colFirst"><code>&lt;TT extends java.lang.Throwable&gt;<br><a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#mapFailure(java.lang.Class,java.util.function.Function)">mapFailure</a></span>&#8203;(java.lang.Class&lt;TT&gt;&nbsp;throwableType,
          java.util.function.Function&lt;? super TT,&#8203;? extends T&gt;&nbsp;mapper)</code></th>
<td class="colLast">
<div class="block">Similar to <a href="ListenableFuture.html#throwMap(java.util.function.Function)"><code>ListenableFuture.throwMap(Function)</code></a> except this mapper will only be invoked when the 
 future is in a failure state (from either the original computation or an earlier mapper 
 throwing an exception).</div>
</td>
</tr>
<tr id="i18" class="altColor">
<td class="colFirst"><code>&lt;TT extends java.lang.Throwable&gt;<br><a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#mapFailure(java.lang.Class,java.util.function.Function,java.util.concurrent.Executor)">mapFailure</a></span>&#8203;(java.lang.Class&lt;TT&gt;&nbsp;throwableType,
          java.util.function.Function&lt;? super TT,&#8203;? extends T&gt;&nbsp;mapper,
          java.util.concurrent.Executor&nbsp;executor)</code></th>
<td class="colLast">
<div class="block">Similar to <a href="ListenableFuture.html#throwMap(java.util.function.Function,java.util.concurrent.Executor)"><code>ListenableFuture.throwMap(Function, Executor)</code></a> except this mapper will only be invoked when 
 the future is in a failure state (from either the original computation or an earlier mapper 
 throwing an exception).</div>
</td>
</tr>
<tr id="i19" class="rowColor">
<td class="colFirst"><code>&lt;TT extends java.lang.Throwable&gt;<br><a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#mapFailure(java.lang.Class,java.util.function.Function,java.util.concurrent.Executor,org.threadly.concurrent.future.ListenableFuture.ListenerOptimizationStrategy)">mapFailure</a></span>&#8203;(java.lang.Class&lt;TT&gt;&nbsp;throwableType,
          java.util.function.Function&lt;? super TT,&#8203;? extends T&gt;&nbsp;mapper,
          java.util.concurrent.Executor&nbsp;executor,
          <a href="ListenableFuture.ListenerOptimizationStrategy.html" title="enum in org.threadly.concurrent.future">ListenableFuture.ListenerOptimizationStrategy</a>&nbsp;optimizeExecution)</code></th>
<td class="colLast">
<div class="block">Similar to <a href="ListenableFuture.html#throwMap(java.util.function.Function,java.util.concurrent.Executor,org.threadly.concurrent.future.ListenableFuture.ListenerOptimizationStrategy)"><code>ListenableFuture.throwMap(Function, Executor, ListenerOptimizationStrategy)</code></a> except this 
 mapper will only be invoked when the future is in a failure state (from either the original 
 computation or an earlier mapper throwing an exception).</div>
</td>
</tr>
<tr id="i20" class="altColor">
<td class="colFirst"><code><a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#resultCallback(java.util.function.Consumer,java.util.concurrent.Executor,org.threadly.concurrent.future.ListenableFuture.ListenerOptimizationStrategy)">resultCallback</a></span>&#8203;(java.util.function.Consumer&lt;? super T&gt;&nbsp;callback,
              java.util.concurrent.Executor&nbsp;executor,
              <a href="ListenableFuture.ListenerOptimizationStrategy.html" title="enum in org.threadly.concurrent.future">ListenableFuture.ListenerOptimizationStrategy</a>&nbsp;optimize)</code></th>
<td class="colLast">
<div class="block">Add a <code>Consumer</code> to be called once the future has completed.</div>
</td>
</tr>
<tr id="i21" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#run()">run</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr id="i22" class="altColor">
<td class="colFirst"><code>java.lang.String</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toString()">toString</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>equals, getClass, hashCode, notify, notifyAll, wait, wait, wait</code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.java.util.concurrent.Future">
<!--   -->
</a>
<h3>Methods inherited from interface&nbsp;java.util.concurrent.Future</h3>
<code>cancel, get, get, isCancelled, isDone</code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.org.threadly.concurrent.future.ListenableFuture">
<!--   -->
</a>
<h3>Methods inherited from interface&nbsp;org.threadly.concurrent.future.<a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a></h3>
<code><a href="ListenableFuture.html#callback(org.threadly.concurrent.future.FutureCallback)">callback</a>, <a href="ListenableFuture.html#callback(org.threadly.concurrent.future.FutureCallback,java.util.concurrent.Executor)">callback</a>, <a href="ListenableFuture.html#callback(org.threadly.concurrent.future.FutureCallback,java.util.concurrent.Executor,org.threadly.concurrent.future.ListenableFuture.ListenerOptimizationStrategy)">callback</a>, <a href="ListenableFuture.html#failureCallback(java.util.function.Consumer)">failureCallback</a>, <a href="ListenableFuture.html#failureCallback(java.util.function.Consumer,java.util.concurrent.Executor)">failureCallback</a>, <a href="ListenableFuture.html#failureCallback(java.util.function.Consumer,java.util.concurrent.Executor,org.threadly.concurrent.future.ListenableFuture.ListenerOptimizationStrategy)">failureCallback</a>, <a href="ListenableFuture.html#flatMap(java.util.function.Function)">flatMap</a>, <a href="ListenableFuture.html#flatMap(java.util.function.Function,java.util.concurrent.Executor)">flatMap</a>, <a href="ListenableFuture.html#flatMap(java.util.function.Function,java.util.concurrent.Executor,org.threadly.concurrent.future.ListenableFuture.ListenerOptimizationStrategy)">flatMap</a>, <a href="ListenableFuture.html#flatMap(org.threadly.concurrent.future.ListenableFuture)">flatMap</a>, <a href="ListenableFuture.html#flatMapFailure(java.lang.Class,java.util.function.Function)">flatMapFailure</a>, <a href="ListenableFuture.html#flatMapFailure(java.lang.Class,java.util.function.Function,java.util.concurrent.Executor)">flatMapFailure</a>, <a href="ListenableFuture.html#flatMapFailure(java.lang.Class,java.util.function.Function,java.util.concurrent.Executor,org.threadly.concurrent.future.ListenableFuture.ListenerOptimizationStrategy)">flatMapFailure</a>, <a href="ListenableFuture.html#getFailure()">getFailure</a>, <a href="ListenableFuture.html#getFailure(long,java.util.concurrent.TimeUnit)">getFailure</a>, <a href="ListenableFuture.html#getRunningStackTrace()">getRunningStackTrace</a>, <a href="ListenableFuture.html#isCompletedExceptionally()">isCompletedExceptionally</a>, <a href="ListenableFuture.html#listener(java.lang.Runnable)">listener</a>, <a href="ListenableFuture.html#listener(java.lang.Runnable,java.util.concurrent.Executor)">listener</a>, <a href="ListenableFuture.html#listener(java.lang.Runnable,java.util.concurrent.Executor,org.threadly.concurrent.future.ListenableFuture.ListenerOptimizationStrategy)">listener</a>, <a href="ListenableFuture.html#map(java.util.function.Function)">map</a>, <a href="ListenableFuture.html#map(java.util.function.Function,java.util.concurrent.Executor)">map</a>, <a href="ListenableFuture.html#map(java.util.function.Function,java.util.concurrent.Executor,org.threadly.concurrent.future.ListenableFuture.ListenerOptimizationStrategy)">map</a>, <a href="ListenableFuture.html#mapFailure(java.lang.Class,java.util.function.Function)">mapFailure</a>, <a href="ListenableFuture.html#mapFailure(java.lang.Class,java.util.function.Function,java.util.concurrent.Executor)">mapFailure</a>, <a href="ListenableFuture.html#mapFailure(java.lang.Class,java.util.function.Function,java.util.concurrent.Executor,org.threadly.concurrent.future.ListenableFuture.ListenerOptimizationStrategy)">mapFailure</a>, <a href="ListenableFuture.html#resultCallback(java.util.function.Consumer)">resultCallback</a>, <a href="ListenableFuture.html#resultCallback(java.util.function.Consumer,java.util.concurrent.Executor)">resultCallback</a>, <a href="ListenableFuture.html#resultCallback(java.util.function.Consumer,java.util.concurrent.Executor,org.threadly.concurrent.future.ListenableFuture.ListenerOptimizationStrategy)">resultCallback</a>, <a href="ListenableFuture.html#throwMap(java.util.function.Function)">throwMap</a>, <a href="ListenableFuture.html#throwMap(java.util.function.Function,java.util.concurrent.Executor)">throwMap</a>, <a href="ListenableFuture.html#throwMap(java.util.function.Function,java.util.concurrent.Executor,org.threadly.concurrent.future.ListenableFuture.ListenerOptimizationStrategy)">throwMap</a></code></li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="constructor.detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a id="&lt;init&gt;(java.lang.Runnable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ListenableFutureTask</h4>
<pre>public&nbsp;ListenableFutureTask&#8203;(java.lang.Runnable&nbsp;task)</pre>
<div class="block">Constructs a runnable future with a runnable work unit.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>task</code> - runnable to be run</dd>
</dl>
</li>
</ul>
<a id="&lt;init&gt;(java.lang.Runnable,java.lang.Object)">
<!--   -->
</a><a id="&lt;init&gt;(java.lang.Runnable,T)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ListenableFutureTask</h4>
<pre>public&nbsp;ListenableFutureTask&#8203;(java.lang.Runnable&nbsp;task,
                            <a href="ListenableFutureTask.html" title="type parameter in ListenableFutureTask">T</a>&nbsp;result)</pre>
<div class="block">Constructs a runnable future with a runnable work unit.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>task</code> - runnable to be run</dd>
<dd><code>result</code> - result to be provide after run has completed</dd>
</dl>
</li>
</ul>
<a id="&lt;init&gt;(java.util.concurrent.Callable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ListenableFutureTask</h4>
<pre>public&nbsp;ListenableFutureTask&#8203;(java.util.concurrent.Callable&lt;<a href="ListenableFutureTask.html" title="type parameter in ListenableFutureTask">T</a>&gt;&nbsp;task)</pre>
<div class="block">Constructs a runnable future with a callable work unit.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>task</code> - callable to be run</dd>
</dl>
</li>
</ul>
<a id="&lt;init&gt;(java.lang.Runnable,java.lang.Object,java.util.concurrent.Executor)">
<!--   -->
</a><a id="&lt;init&gt;(java.lang.Runnable,T,java.util.concurrent.Executor)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ListenableFutureTask</h4>
<pre>public&nbsp;ListenableFutureTask&#8203;(java.lang.Runnable&nbsp;task,
                            <a href="ListenableFutureTask.html" title="type parameter in ListenableFutureTask">T</a>&nbsp;result,
                            java.util.concurrent.Executor&nbsp;executingExecutor)</pre>
<div class="block">Constructs a runnable future with a runnable work unit.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>task</code> - runnable to be run</dd>
<dd><code>result</code> - result to be provide after run has completed</dd>
<dd><code>executingExecutor</code> - Executor task will be run on for possible listener optimization, or <code>null</code></dd>
</dl>
</li>
</ul>
<a id="&lt;init&gt;(java.util.concurrent.Callable,java.util.concurrent.Executor)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>ListenableFutureTask</h4>
<pre>public&nbsp;ListenableFutureTask&#8203;(java.util.concurrent.Callable&lt;<a href="ListenableFutureTask.html" title="type parameter in ListenableFutureTask">T</a>&gt;&nbsp;task,
                            java.util.concurrent.Executor&nbsp;executingExecutor)</pre>
<div class="block">Constructs a runnable future with a callable work unit.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>task</code> - callable to be run</dd>
<dd><code>executingExecutor</code> - Executor task will be run on for possible listener optimization, or <code>null</code></dd>
</dl>
</li>
</ul>
</li>
</ul>
</section>
<!-- ============ METHOD DETAIL ========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a id="run()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>run</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;run()</pre>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>run</code>&nbsp;in interface&nbsp;<code>java.lang.Runnable</code></dd>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code>run</code>&nbsp;in interface&nbsp;<code>java.util.concurrent.RunnableFuture&lt;<a href="ListenableFutureTask.html" title="type parameter in ListenableFutureTask">T</a>&gt;</code></dd>
</dl>
</li>
</ul>
<a id="getContainedCallable()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getContainedCallable</h4>
<pre class="methodSignature">public&nbsp;java.util.concurrent.Callable&lt;<a href="ListenableFutureTask.html" title="type parameter in ListenableFutureTask">T</a>&gt;&nbsp;getContainedCallable()</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from interface:&nbsp;<code><a href="../CallableContainer.html#getContainedCallable()">CallableContainer</a></code></span></div>
<div class="block">Call to get the contained callable held within the wrapper.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../CallableContainer.html#getContainedCallable()">getContainedCallable</a></code>&nbsp;in interface&nbsp;<code><a href="../CallableContainer.html" title="interface in org.threadly.concurrent">CallableContainer</a>&lt;<a href="ListenableFutureTask.html" title="type parameter in ListenableFutureTask">T</a>&gt;</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>callable contained within wrapper, or <code>null</code> if none is contained</dd>
</dl>
</li>
</ul>
<a id="toString()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toString</h4>
<pre class="methodSignature">public&nbsp;java.lang.String&nbsp;toString()</pre>
</li>
</ul>
<a id="clearResult()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clearResult</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;clearResult()</pre>
<div class="block">Clears the stored result from this set future.  This allows the result to be available for 
 garbage collection.  After this call, future calls to <code>Future.get()</code> will throw an 
 <code>IllegalStateException</code>.  So it is critical that this is only called after you are sure 
 no future calls to get the result on this future will be attempted.
 <p>
 The design of this is so that if you want to chain <a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future"><code>ListenableFuture</code></a>'s together, you 
 can clear the results of old ones after their result has been consumed.  This is really only 
 useful in very specific instances.
 <p>
 WARNING, this may produce some unexpected behaviors.  For example if the result is being pulled 
 while this is concurrently invoked a <code>null</code> result may be returned when a result was 
 previously available.  In addition <code>Future.get()</code> and <a href="ListenableFuture.html#callback(org.threadly.concurrent.future.FutureCallback)"><code>ListenableFuture.callback(FutureCallback)</code></a> attempt 
 to reliably error in this condition but <a href="ListenableFuture.html#failureCallback(java.util.function.Consumer)"><code>ListenableFuture.failureCallback(Consumer)</code></a> and 
 <a href="ListenableFuture.html#resultCallback(java.util.function.Consumer)"><code>ListenableFuture.resultCallback(Consumer)</code></a> do not.  <a href="ListenableFuture.html#failureCallback(java.util.function.Consumer)"><code>ListenableFuture.failureCallback(Consumer)</code></a> will only show 
 the unexpected clearResult state if the future had finished in a failure condition we can't 
 report.  And <a href="ListenableFuture.html#resultCallback(java.util.function.Consumer)"><code>ListenableFuture.resultCallback(Consumer)</code></a> will always be a no-op after clearing.  In short
 BE CAUTIOUS, only use this if you are certain the result or failure wont be re-queried and 
 you understand the risks.</div>
</li>
</ul>
<a id="cancel(boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>cancel</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;cancel&#8203;(boolean&nbsp;interrupt)</pre>
</li>
</ul>
<a id="listener(java.lang.Runnable,java.util.concurrent.Executor,org.threadly.concurrent.future.ListenableFuture.ListenerOptimizationStrategy)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>listener</h4>
<pre class="methodSignature">public&nbsp;<a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;T&gt;&nbsp;listener&#8203;(java.lang.Runnable&nbsp;listener,
                                    java.util.concurrent.Executor&nbsp;executor,
                                    <a href="ListenableFuture.ListenerOptimizationStrategy.html" title="enum in org.threadly.concurrent.future">ListenableFuture.ListenerOptimizationStrategy</a>&nbsp;optimize)</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from interface:&nbsp;<code><a href="ListenableFuture.html#listener(java.lang.Runnable,java.util.concurrent.Executor,org.threadly.concurrent.future.ListenableFuture.ListenerOptimizationStrategy)">ListenableFuture</a></code></span></div>
<div class="block">Add a listener to be called once the future has completed.  If the future has already 
 finished, this will be called immediately.
 <p>
 If the provided <code>Executor</code> is null, the listener will execute on the thread which 
 computed the original future (once it is done).  If the future has already completed, the 
 listener will execute immediately on the thread which is adding the listener.
 <p>
 Caution should be used when choosing to optimize the listener execution.  If the listener is 
 complex, or wanting to be run concurrent, this optimization could prevent that.  In addition 
 it will prevent other listeners from potentially being invoked until it completes.  However 
 if the listener is small / fast, this can provide significant performance gains.  It should 
 also be known that not all <a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future"><code>ListenableFuture</code></a> implementations may be able to do such an 
 optimization.  Please see <a href="ListenableFuture.ListenerOptimizationStrategy.html" title="enum in org.threadly.concurrent.future"><code>ListenableFuture.ListenerOptimizationStrategy</code></a> javadocs for more specific 
 details of what optimizations are available.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>listener</code> - the listener to run when the computation is complete</dd>
<dd><code>executor</code> - <code>Executor</code> the listener should be ran on, or <code>null</code></dd>
<dd><code>optimize</code> - <code>true</code> to avoid listener queuing for execution if already on the desired pool</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Exactly <code>this</code> instance to add more listeners or other functional operations</dd>
</dl>
</li>
</ul>
<a id="getRunningStackTrace()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRunningStackTrace</h4>
<pre class="methodSignature">public&nbsp;java.lang.StackTraceElement[]&nbsp;getRunningStackTrace()</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from interface:&nbsp;<code><a href="ListenableFuture.html#getRunningStackTrace()">ListenableFuture</a></code></span></div>
<div class="block">A best effort to return the stack trace for for the executing thread of either this future, 
 or a future which this depends on through the use of <a href="ListenableFuture.html#map(java.util.function.Function)"><code>ListenableFuture.map(Function)</code></a> or similar 
 functions.  If there is no thread executing the future yet, or the future has already 
 completed, then this will return <code>null</code>. 
 <p>
 This is done without locking (though generating a stack trace still requires a JVM safe point), 
 so the resulting stack trace is NOT guaranteed to be accurate.  In most cases (particularly 
 when blocking) this should be accurate though.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The stack trace currently executing the future, or <code>null</code> if unavailable</dd>
</dl>
</li>
</ul>
<a id="isCancelled()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isCancelled</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;isCancelled()</pre>
</li>
</ul>
<a id="isDone()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isDone</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;isDone()</pre>
</li>
</ul>
<a id="isCompletedExceptionally()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isCompletedExceptionally</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;isCompletedExceptionally()</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from interface:&nbsp;<code><a href="ListenableFuture.html#isCompletedExceptionally()">ListenableFuture</a></code></span></div>
<div class="block">Returns <code>true</code> if the future is both done and has completed with an error or was 
 canceled.  If this returns <code>true</code> the <code>Throwable</code> responsible for the error can 
 be retrieved using <a href="ListenableFuture.html#getFailure()"><code>ListenableFuture.getFailure()</code></a>;</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>true</code> if this ListenableFuture completed by a thrown Exception or was canceled</dd>
</dl>
</li>
</ul>
<a id="get()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>get</h4>
<pre class="methodSignature">public&nbsp;T&nbsp;get()
      throws java.lang.InterruptedException,
             java.util.concurrent.ExecutionException</pre>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.InterruptedException</code></dd>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
</dl>
</li>
</ul>
<a id="get(long,java.util.concurrent.TimeUnit)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>get</h4>
<pre class="methodSignature">public&nbsp;T&nbsp;get&#8203;(long&nbsp;timeout,
             java.util.concurrent.TimeUnit&nbsp;unit)
      throws java.lang.InterruptedException,
             java.util.concurrent.ExecutionException,
             java.util.concurrent.TimeoutException</pre>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.InterruptedException</code></dd>
<dd><code>java.util.concurrent.ExecutionException</code></dd>
<dd><code>java.util.concurrent.TimeoutException</code></dd>
</dl>
</li>
</ul>
<a id="getFailure()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getFailure</h4>
<pre class="methodSignature">public&nbsp;java.lang.Throwable&nbsp;getFailure()
                               throws java.lang.InterruptedException</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from interface:&nbsp;<code><a href="ListenableFuture.html#getFailure()">ListenableFuture</a></code></span></div>
<div class="block">Similar to <code>Future.get()</code> except instead of providing a result, this will provide a thrown 
 exception if <a href="ListenableFuture.html#isCompletedExceptionally()"><code>ListenableFuture.isCompletedExceptionally()</code></a> returns <code>true</code>.  If the future has not 
 completed yet this function will block until completion.  If the future completed normally, 
 this will return <code>null</code>.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Throwable thrown in computing the future or <code>null</code> if completed normally</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.InterruptedException</code> - If the current thread was interrupted while blocking</dd>
</dl>
</li>
</ul>
<a id="getFailure(long,java.util.concurrent.TimeUnit)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getFailure</h4>
<pre class="methodSignature">public&nbsp;java.lang.Throwable&nbsp;getFailure&#8203;(long&nbsp;timeout,
                                      java.util.concurrent.TimeUnit&nbsp;unit)
                               throws java.lang.InterruptedException,
                                      java.util.concurrent.TimeoutException</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from interface:&nbsp;<code><a href="ListenableFuture.html#getFailure(long,java.util.concurrent.TimeUnit)">ListenableFuture</a></code></span></div>
<div class="block">Similar to <code>Future.get(long, TimeUnit)</code> except instead of providing a result, this will 
 provide a thrown exception if <a href="ListenableFuture.html#isCompletedExceptionally()"><code>ListenableFuture.isCompletedExceptionally()</code></a> returns <code>true</code>.  If 
 the future has not completed yet this function will block until completion.  If the future 
 completed normally, this will return <code>null</code>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>timeout</code> - The maximum time to wait</dd>
<dd><code>unit</code> - The time unit of the timeout argument</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Throwable thrown in computing the future or <code>null</code> if completed normally</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.InterruptedException</code> - If the current thread was interrupted while blocking</dd>
<dd><code>java.util.concurrent.TimeoutException</code> - If the timeout was reached before the future completed</dd>
</dl>
</li>
</ul>
<a id="callback(org.threadly.concurrent.future.FutureCallback,java.util.concurrent.Executor,org.threadly.concurrent.future.ListenableFuture.ListenerOptimizationStrategy)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>callback</h4>
<pre class="methodSignature">public&nbsp;<a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;T&gt;&nbsp;callback&#8203;(<a href="FutureCallback.html" title="interface in org.threadly.concurrent.future">FutureCallback</a>&lt;? super T&gt;&nbsp;callback,
                                    java.util.concurrent.Executor&nbsp;executor,
                                    <a href="ListenableFuture.ListenerOptimizationStrategy.html" title="enum in org.threadly.concurrent.future">ListenableFuture.ListenerOptimizationStrategy</a>&nbsp;optimize)</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from interface:&nbsp;<code><a href="ListenableFuture.html#callback(org.threadly.concurrent.future.FutureCallback,java.util.concurrent.Executor,org.threadly.concurrent.future.ListenableFuture.ListenerOptimizationStrategy)">ListenableFuture</a></code></span></div>
<div class="block">Add a <a href="FutureCallback.html" title="interface in org.threadly.concurrent.future"><code>FutureCallback</code></a> to be called once the future has completed.  If the future has 
 already finished, this will be called immediately.
 <p>
 If the provided <code>Executor</code> is null, the callback will execute on the thread which 
 computed the original future (once it is done).  If the future has already completed, the 
 callback will execute immediately on the thread which is adding the callback.
 <p>
 Caution should be used when choosing to optimize the listener execution.  If the listener is 
 complex, or wanting to be run concurrent, this optimization could prevent that.  In addition 
 it will prevent other listeners from potentially being invoked until it completes.  However 
 if the listener is small / fast, this can provide significant performance gains.  It should 
 also be known that not all <a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future"><code>ListenableFuture</code></a> implementations may be able to do such an 
 optimization.  Please see <a href="ListenableFuture.ListenerOptimizationStrategy.html" title="enum in org.threadly.concurrent.future"><code>ListenableFuture.ListenerOptimizationStrategy</code></a> javadocs for more specific 
 details of what optimizations are available.
 <p>
 If you only care about the success result case please see 
 <a href="ListenableFuture.html#resultCallback(java.util.function.Consumer,java.util.concurrent.Executor,org.threadly.concurrent.future.ListenableFuture.ListenerOptimizationStrategy)"><code>ListenableFuture.resultCallback(Consumer, Executor, ListenerOptimizationStrategy)</code></a> or conversely if you 
 only want to be invoked for failure cases please see 
 <a href="ListenableFuture.html#failureCallback(java.util.function.Consumer,java.util.concurrent.Executor,org.threadly.concurrent.future.ListenableFuture.ListenerOptimizationStrategy)"><code>ListenableFuture.failureCallback(Consumer, Executor, ListenerOptimizationStrategy)</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>callback</code> - to be invoked when the computation is complete</dd>
<dd><code>executor</code> - <code>Executor</code> the callback should be ran on, or <code>null</code></dd>
<dd><code>optimize</code> - <code>true</code> to avoid listener queuing for execution if already on the desired pool</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Exactly <code>this</code> instance to add more callbacks or other functional operations</dd>
</dl>
</li>
</ul>
<a id="resultCallback(java.util.function.Consumer,java.util.concurrent.Executor,org.threadly.concurrent.future.ListenableFuture.ListenerOptimizationStrategy)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>resultCallback</h4>
<pre class="methodSignature">public&nbsp;<a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;T&gt;&nbsp;resultCallback&#8203;(java.util.function.Consumer&lt;? super T&gt;&nbsp;callback,
                                          java.util.concurrent.Executor&nbsp;executor,
                                          <a href="ListenableFuture.ListenerOptimizationStrategy.html" title="enum in org.threadly.concurrent.future">ListenableFuture.ListenerOptimizationStrategy</a>&nbsp;optimize)</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from interface:&nbsp;<code><a href="ListenableFuture.html#resultCallback(java.util.function.Consumer,java.util.concurrent.Executor,org.threadly.concurrent.future.ListenableFuture.ListenerOptimizationStrategy)">ListenableFuture</a></code></span></div>
<div class="block">Add a <code>Consumer</code> to be called once the future has completed.  If the future has 
 already finished, this will be called immediately.  Assuming the future has completed without 
 error, the result will be provided to the <code>Consumer</code>, otherwise it will go un-invoked.
 <p>
 If the provided <code>Executor</code> is null, the callback will execute on the thread which 
 computed the original future (once it is done).  If the future has already completed, the 
 callback will execute immediately on the thread which is adding the callback.
 <p>
 Caution should be used when choosing to optimize the listener execution.  If the listener is 
 complex, or wanting to be run concurrent, this optimization could prevent that.  In addition 
 it will prevent other listeners from potentially being invoked until it completes.  However 
 if the listener is small / fast, this can provide significant performance gains.  It should 
 also be known that not all <a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future"><code>ListenableFuture</code></a> implementations may be able to do such an 
 optimization.  Please see <a href="ListenableFuture.ListenerOptimizationStrategy.html" title="enum in org.threadly.concurrent.future"><code>ListenableFuture.ListenerOptimizationStrategy</code></a> javadocs for more specific 
 details of what optimizations are available.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>callback</code> - to be invoked when the computation is complete</dd>
<dd><code>executor</code> - <code>Executor</code> the callback should be ran on, or <code>null</code></dd>
<dd><code>optimize</code> - <code>true</code> to avoid listener queuing for execution if already on the desired pool</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Exactly <code>this</code> instance to add more callbacks or other functional operations</dd>
</dl>
</li>
</ul>
<a id="failureCallback(java.util.function.Consumer,java.util.concurrent.Executor,org.threadly.concurrent.future.ListenableFuture.ListenerOptimizationStrategy)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>failureCallback</h4>
<pre class="methodSignature">public&nbsp;<a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;T&gt;&nbsp;failureCallback&#8203;(java.util.function.Consumer&lt;java.lang.Throwable&gt;&nbsp;callback,
                                           java.util.concurrent.Executor&nbsp;executor,
                                           <a href="ListenableFuture.ListenerOptimizationStrategy.html" title="enum in org.threadly.concurrent.future">ListenableFuture.ListenerOptimizationStrategy</a>&nbsp;optimize)</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from interface:&nbsp;<code><a href="ListenableFuture.html#failureCallback(java.util.function.Consumer,java.util.concurrent.Executor,org.threadly.concurrent.future.ListenableFuture.ListenerOptimizationStrategy)">ListenableFuture</a></code></span></div>
<div class="block">Add a <code>Consumer</code> to be called once the future has completed.  If the future has 
 already finished, this will be called immediately.  Assuming the future has completed with an 
 error, the <code>Throwable</code> will be provided to the <code>Consumer</code>, otherwise if no error 
 occurred, the callback will go un-invoked.
 <p>
 If the provided <code>Executor</code> is null, the callback will execute on the thread which 
 computed the original future (once it is done).  If the future has already completed, the 
 callback will execute immediately on the thread which is adding the callback.
 <p>
 Caution should be used when choosing to optimize the listener execution.  If the listener is 
 complex, or wanting to be run concurrent, this optimization could prevent that.  In addition 
 it will prevent other listeners from potentially being invoked until it completes.  However 
 if the listener is small / fast, this can provide significant performance gains.  It should 
 also be known that not all <a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future"><code>ListenableFuture</code></a> implementations may be able to do such an 
 optimization.  Please see <a href="ListenableFuture.ListenerOptimizationStrategy.html" title="enum in org.threadly.concurrent.future"><code>ListenableFuture.ListenerOptimizationStrategy</code></a> javadocs for more specific 
 details of what optimizations are available.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>callback</code> - to be invoked when the computation is complete</dd>
<dd><code>executor</code> - <code>Executor</code> the callback should be ran on, or <code>null</code></dd>
<dd><code>optimize</code> - <code>true</code> to avoid listener queuing for execution if already on the desired pool</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Exactly <code>this</code> instance to add more callbacks or other functional operations</dd>
</dl>
</li>
</ul>
<a id="mapFailure(java.lang.Class,java.util.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mapFailure</h4>
<pre class="methodSignature">public&nbsp;&lt;TT extends java.lang.Throwable&gt;&nbsp;<a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;T&gt;&nbsp;mapFailure&#8203;(java.lang.Class&lt;TT&gt;&nbsp;throwableType,
                                                                       java.util.function.Function&lt;? super TT,&#8203;? extends T&gt;&nbsp;mapper)</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from interface:&nbsp;<code><a href="ListenableFuture.html#mapFailure(java.lang.Class,java.util.function.Function)">ListenableFuture</a></code></span></div>
<div class="block">Similar to <a href="ListenableFuture.html#throwMap(java.util.function.Function)"><code>ListenableFuture.throwMap(Function)</code></a> except this mapper will only be invoked when the 
 future is in a failure state (from either the original computation or an earlier mapper 
 throwing an exception).  If this future does resolve in a failure state, and that exception 
 class matches the one provided here.  The mapper function will then be provided that 
 throwable, it can then map that throwable back into a result (perhaps an <code>Optional</code>), 
 or re-throw either the same or a different exception keep the future in a failure state.  If 
 the future completes with a normal result, this mapper will be ignored, and the result will 
 be forwarded on without invoking this mapper.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="ListenableFuture.html#mapFailure(java.lang.Class,java.util.function.Function)">mapFailure</a></code>&nbsp;in interface&nbsp;<code><a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;T&gt;</code></dd>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>TT</code> - The type of throwable that should be handled</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>throwableType</code> - The class referencing to the type of throwable this mapper handles</dd>
<dd><code>mapper</code> - The mapper to convert a thrown exception to either a result or thrown exception</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future"><code>ListenableFuture</code></a> that will resolve after the mapper is considered</dd>
</dl>
</li>
</ul>
<a id="mapFailure(java.lang.Class,java.util.function.Function,java.util.concurrent.Executor)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mapFailure</h4>
<pre class="methodSignature">public&nbsp;&lt;TT extends java.lang.Throwable&gt;&nbsp;<a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;T&gt;&nbsp;mapFailure&#8203;(java.lang.Class&lt;TT&gt;&nbsp;throwableType,
                                                                       java.util.function.Function&lt;? super TT,&#8203;? extends T&gt;&nbsp;mapper,
                                                                       java.util.concurrent.Executor&nbsp;executor)</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from interface:&nbsp;<code><a href="ListenableFuture.html#mapFailure(java.lang.Class,java.util.function.Function,java.util.concurrent.Executor)">ListenableFuture</a></code></span></div>
<div class="block">Similar to <a href="ListenableFuture.html#throwMap(java.util.function.Function,java.util.concurrent.Executor)"><code>ListenableFuture.throwMap(Function, Executor)</code></a> except this mapper will only be invoked when 
 the future is in a failure state (from either the original computation or an earlier mapper 
 throwing an exception).  If this future does resolve in a failure state, and that exception 
 class matches the one provided here.  The mapper function will then be provided that 
 throwable, it can then map that throwable back into a result (perhaps an <code>Optional</code>), 
 or re-throw either the same or a different exception keep the future in a failure state.  If 
 the future completes with a normal result, this mapper will be ignored, and the result will 
 be forwarded on without invoking this mapper.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="ListenableFuture.html#mapFailure(java.lang.Class,java.util.function.Function,java.util.concurrent.Executor)">mapFailure</a></code>&nbsp;in interface&nbsp;<code><a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;T&gt;</code></dd>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>TT</code> - The type of throwable that should be handled</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>throwableType</code> - The class referencing to the type of throwable this mapper handles</dd>
<dd><code>mapper</code> - The mapper to convert a thrown exception to either a result or thrown exception</dd>
<dd><code>executor</code> - Executor to invoke mapper function on, or <code>null</code> 
          to invoke on this thread or future complete thread (depending on future state)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future"><code>ListenableFuture</code></a> that will resolve after the mapper is considered</dd>
</dl>
</li>
</ul>
<a id="mapFailure(java.lang.Class,java.util.function.Function,java.util.concurrent.Executor,org.threadly.concurrent.future.ListenableFuture.ListenerOptimizationStrategy)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mapFailure</h4>
<pre class="methodSignature">public&nbsp;&lt;TT extends java.lang.Throwable&gt;&nbsp;<a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;T&gt;&nbsp;mapFailure&#8203;(java.lang.Class&lt;TT&gt;&nbsp;throwableType,
                                                                       java.util.function.Function&lt;? super TT,&#8203;? extends T&gt;&nbsp;mapper,
                                                                       java.util.concurrent.Executor&nbsp;executor,
                                                                       <a href="ListenableFuture.ListenerOptimizationStrategy.html" title="enum in org.threadly.concurrent.future">ListenableFuture.ListenerOptimizationStrategy</a>&nbsp;optimizeExecution)</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from interface:&nbsp;<code><a href="ListenableFuture.html#mapFailure(java.lang.Class,java.util.function.Function,java.util.concurrent.Executor,org.threadly.concurrent.future.ListenableFuture.ListenerOptimizationStrategy)">ListenableFuture</a></code></span></div>
<div class="block">Similar to <a href="ListenableFuture.html#throwMap(java.util.function.Function,java.util.concurrent.Executor,org.threadly.concurrent.future.ListenableFuture.ListenerOptimizationStrategy)"><code>ListenableFuture.throwMap(Function, Executor, ListenerOptimizationStrategy)</code></a> except this 
 mapper will only be invoked when the future is in a failure state (from either the original 
 computation or an earlier mapper throwing an exception).  If this future does resolve in a 
 failure state, and that exception class matches the one provided here.  The mapper function 
 will then be provided that throwable, it can then map that throwable back into a result 
 perhaps an <code>Optional</code>), or re-throw either the same or a different exception keep the 
 future in a failure state.  If the future completes with a normal result, this mapper will be 
 ignored, and the result will be forwarded on without invoking this mapper.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="ListenableFuture.html#mapFailure(java.lang.Class,java.util.function.Function,java.util.concurrent.Executor,org.threadly.concurrent.future.ListenableFuture.ListenerOptimizationStrategy)">mapFailure</a></code>&nbsp;in interface&nbsp;<code><a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;T&gt;</code></dd>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>TT</code> - The type of throwable that should be handled</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>throwableType</code> - The class referencing to the type of throwable this mapper handles</dd>
<dd><code>mapper</code> - The mapper to convert a thrown exception to either a result or thrown exception</dd>
<dd><code>executor</code> - Executor to invoke mapper function on, or <code>null</code> 
          to invoke on this thread or future complete thread (depending on future state)</dd>
<dd><code>optimizeExecution</code> - <code>true</code> to avoid listener queuing for execution if already on the desired pool</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future"><code>ListenableFuture</code></a> that will resolve after the mapper is considered</dd>
</dl>
</li>
</ul>
<a id="flatMapFailure(java.lang.Class,java.util.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>flatMapFailure</h4>
<pre class="methodSignature">public&nbsp;&lt;TT extends java.lang.Throwable&gt;&nbsp;<a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;T&gt;&nbsp;flatMapFailure&#8203;(java.lang.Class&lt;TT&gt;&nbsp;throwableType,
                                                                           java.util.function.Function&lt;? super TT,&#8203;<a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;T&gt;&gt;&nbsp;mapper)</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from interface:&nbsp;<code><a href="ListenableFuture.html#flatMapFailure(java.lang.Class,java.util.function.Function)">ListenableFuture</a></code></span></div>
<div class="block">Similar to <a href="ListenableFuture.html#mapFailure(java.lang.Class,java.util.function.Function)"><code>ListenableFuture.mapFailure(Class, Function)</code></a> except that this mapper function returns a 
 <a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future"><code>ListenableFuture</code></a> if it needs to map the Throwable / failure into a result or another 
 failure.  The mapper function can return a Future that will (or may) provide a result, or it 
 can provide a future that will result in the same or another failure.  Similar to  
 <a href="ListenableFuture.html#mapFailure(java.lang.Class,java.util.function.Function)"><code>ListenableFuture.mapFailure(Class, Function)</code></a> the mapper can also throw an exception directly.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="ListenableFuture.html#flatMapFailure(java.lang.Class,java.util.function.Function)">flatMapFailure</a></code>&nbsp;in interface&nbsp;<code><a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;T&gt;</code></dd>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>TT</code> - The type of throwable that should be handled</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>throwableType</code> - The class referencing to the type of throwable this mapper handles</dd>
<dd><code>mapper</code> - Function to invoke in order to transform the futures result</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future"><code>ListenableFuture</code></a> that will resolve after the mapper is considered</dd>
</dl>
</li>
</ul>
<a id="flatMapFailure(java.lang.Class,java.util.function.Function,java.util.concurrent.Executor)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>flatMapFailure</h4>
<pre class="methodSignature">public&nbsp;&lt;TT extends java.lang.Throwable&gt;&nbsp;<a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;T&gt;&nbsp;flatMapFailure&#8203;(java.lang.Class&lt;TT&gt;&nbsp;throwableType,
                                                                           java.util.function.Function&lt;? super TT,&#8203;<a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;T&gt;&gt;&nbsp;mapper,
                                                                           java.util.concurrent.Executor&nbsp;executor)</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from interface:&nbsp;<code><a href="ListenableFuture.html#flatMapFailure(java.lang.Class,java.util.function.Function,java.util.concurrent.Executor)">ListenableFuture</a></code></span></div>
<div class="block">Similar to <a href="ListenableFuture.html#mapFailure(java.lang.Class,java.util.function.Function,java.util.concurrent.Executor)"><code>ListenableFuture.mapFailure(Class, Function, Executor)</code></a> except that this mapper function 
 returns a <a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future"><code>ListenableFuture</code></a> if it needs to map the Throwable / failure into a result 
 or another failure.  The mapper function can return a Future that will (or may) provide a 
 result, or it can provide a future that will result in the same or another failure.  Similar 
 to <a href="ListenableFuture.html#mapFailure(java.lang.Class,java.util.function.Function,java.util.concurrent.Executor)"><code>ListenableFuture.mapFailure(Class, Function, Executor)</code></a> the mapper can also throw an exception 
 directly.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="ListenableFuture.html#flatMapFailure(java.lang.Class,java.util.function.Function,java.util.concurrent.Executor)">flatMapFailure</a></code>&nbsp;in interface&nbsp;<code><a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;T&gt;</code></dd>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>TT</code> - The type of throwable that should be handled</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>throwableType</code> - The class referencing to the type of throwable this mapper handles</dd>
<dd><code>mapper</code> - Function to invoke in order to transform the futures result</dd>
<dd><code>executor</code> - Executor to invoke mapper function on, or <code>null</code> 
          to invoke on this thread or future complete thread (depending on future state)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future"><code>ListenableFuture</code></a> that will resolve after the mapper is considered</dd>
</dl>
</li>
</ul>
<a id="flatMapFailure(java.lang.Class,java.util.function.Function,java.util.concurrent.Executor,org.threadly.concurrent.future.ListenableFuture.ListenerOptimizationStrategy)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>flatMapFailure</h4>
<pre class="methodSignature">public&nbsp;&lt;TT extends java.lang.Throwable&gt;&nbsp;<a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;T&gt;&nbsp;flatMapFailure&#8203;(java.lang.Class&lt;TT&gt;&nbsp;throwableType,
                                                                           java.util.function.Function&lt;? super TT,&#8203;<a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;T&gt;&gt;&nbsp;mapper,
                                                                           java.util.concurrent.Executor&nbsp;executor,
                                                                           <a href="ListenableFuture.ListenerOptimizationStrategy.html" title="enum in org.threadly.concurrent.future">ListenableFuture.ListenerOptimizationStrategy</a>&nbsp;optimizeExecution)</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from interface:&nbsp;<code><a href="ListenableFuture.html#flatMapFailure(java.lang.Class,java.util.function.Function,java.util.concurrent.Executor,org.threadly.concurrent.future.ListenableFuture.ListenerOptimizationStrategy)">ListenableFuture</a></code></span></div>
<div class="block">Similar to <a href="ListenableFuture.html#mapFailure(java.lang.Class,java.util.function.Function,java.util.concurrent.Executor,org.threadly.concurrent.future.ListenableFuture.ListenerOptimizationStrategy)"><code>ListenableFuture.mapFailure(Class, Function, Executor, ListenerOptimizationStrategy)</code></a> except 
 that this mapper function returns a <a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future"><code>ListenableFuture</code></a> if it needs to map the Throwable 
 into a result or another failure.  The mapper function can return a Future that will (or may) 
 provide a result, or it can provide a future that will result in the same or another failure.  
 Similar to <a href="ListenableFuture.html#mapFailure(java.lang.Class,java.util.function.Function,java.util.concurrent.Executor,org.threadly.concurrent.future.ListenableFuture.ListenerOptimizationStrategy)"><code>ListenableFuture.mapFailure(Class, Function, Executor, ListenerOptimizationStrategy)</code></a> the 
 mapper can also throw an exception directly.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="ListenableFuture.html#flatMapFailure(java.lang.Class,java.util.function.Function,java.util.concurrent.Executor,org.threadly.concurrent.future.ListenableFuture.ListenerOptimizationStrategy)">flatMapFailure</a></code>&nbsp;in interface&nbsp;<code><a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;T&gt;</code></dd>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>TT</code> - The type of throwable that should be handled</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>throwableType</code> - The class referencing to the type of throwable this mapper handles</dd>
<dd><code>mapper</code> - Function to invoke in order to transform the futures result</dd>
<dd><code>executor</code> - Executor to invoke mapper function on, or <code>null</code> 
          to invoke on this thread or future complete thread (depending on future state)</dd>
<dd><code>optimizeExecution</code> - <code>true</code> to avoid listener queuing for execution if already on the desired pool</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future"><code>ListenableFuture</code></a> that will resolve after the mapper is considered</dd>
</dl>
</li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
</div>
</main>
<!-- ========= END OF CLASS DATA ========= -->
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
</footer>
</body>
</html>
