<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (11.0.1) on Sun Dec 30 11:24:34 MST 2018 -->
<title>FutureUtils (threadly 5.30 API)</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="dc.created" content="2018-12-30">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../jquery/jquery-ui.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
<script type="text/javascript" src="../../../../jquery/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../../../../jquery/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../../../../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../../../../jquery/jquery-3.3.1.js"></script>
<script type="text/javascript" src="../../../../jquery/jquery-migrate-3.0.1.js"></script>
<script type="text/javascript" src="../../../../jquery/jquery-ui.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="FutureUtils (threadly 5.30 API)";
        }
    }
    catch(err) {
    }
//-->
var data = {"i0":9,"i1":9,"i2":9,"i3":9,"i4":9,"i5":9,"i6":9,"i7":9,"i8":9,"i9":9,"i10":9,"i11":9,"i12":9,"i13":9,"i14":9,"i15":9,"i16":9,"i17":9,"i18":9,"i19":9,"i20":9,"i21":9,"i22":9,"i23":9,"i24":9,"i25":9,"i26":9,"i27":9,"i28":9,"i29":41,"i30":41};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],8:["t4","Concrete Methods"],32:["t6","Deprecated Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../../../";
var useModuleDirectories = true;
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<div class="fixedNav">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<ul class="navListSearch">
<li><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
</div>
<div class="navPadding">&nbsp;</div>
<script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script>
</nav>
</header>
<!-- ======== START OF CLASS DATA ======== -->
<main role="main">
<div class="header">
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="package-summary.html">org.threadly.concurrent.future</a></div>
<h2 title="Class FutureUtils" class="title">Class FutureUtils</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>org.threadly.concurrent.future.FutureUtils</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<pre>public class <span class="typeNameLabel">FutureUtils</span>
extends java.lang.Object</pre>
<div class="block">A collection of small utilities for handling futures.  This class has lots of tools for dealing 
 with collections of futures, ranging from blocking, extracting results, and more.
 <p>
 Generating already done futures:
 <ul>
 <li><a href="#immediateResultFuture(T)"><code>immediateResultFuture(Object)</code></a>
 <li><a href="#immediateFailureFuture(java.lang.Throwable)"><code>immediateFailureFuture(Throwable)</code></a>
 </ul>
 <p>
 Tools for blocking:
 <ul>
 <li><a href="#blockTillAllComplete(java.lang.Iterable)"><code>blockTillAllComplete(Iterable)</code></a>
 <li><a href="#blockTillAllComplete(java.lang.Iterable,long)"><code>blockTillAllComplete(Iterable, long)</code></a>
 <li><a href="#blockTillAllCompleteOrFirstError(java.lang.Iterable)"><code>blockTillAllCompleteOrFirstError(Iterable)</code></a>
 <li><a href="#blockTillAllCompleteOrFirstError(java.lang.Iterable,long)"><code>blockTillAllCompleteOrFirstError(Iterable, long)</code></a>
 </ul>
 <p>
 Tools for manipulating collections of futures:
 <ul>
 <li><a href="#cancelIncompleteFutures(java.lang.Iterable,boolean)"><code>cancelIncompleteFutures(Iterable, boolean)</code></a>
 <li><a href="#cancelIncompleteFuturesIfAnyFail(boolean,java.lang.Iterable,boolean)"><code>cancelIncompleteFuturesIfAnyFail(boolean, Iterable, boolean)</code></a>
 <li><a href="#countFuturesWithResult(java.lang.Iterable,T)"><code>countFuturesWithResult(Iterable, Object)</code></a>
 <li><a href="#countFuturesWithResult(java.lang.Iterable,T,long)"><code>countFuturesWithResult(Iterable, Object, long)</code></a>
 <li><a href="#makeCompleteFuture(java.lang.Iterable)"><code>makeCompleteFuture(Iterable)</code></a>
 <li><a href="#makeCompleteFuture(java.lang.Iterable,T)"><code>makeCompleteFuture(Iterable, Object)</code></a>
 <li><a href="#makeFailurePropagatingCompleteFuture(java.lang.Iterable)"><code>makeFailurePropagatingCompleteFuture(Iterable)</code></a>
 <li><a href="#makeFailurePropagatingCompleteFuture(java.lang.Iterable,T)"><code>makeFailurePropagatingCompleteFuture(Iterable, Object)</code></a>
 <li><a href="#makeCompleteListFuture(java.lang.Iterable)"><code>makeCompleteListFuture(Iterable)</code></a>
 <li><a href="#makeFailureListFuture(java.lang.Iterable)"><code>makeFailureListFuture(Iterable)</code></a>
 <li><a href="#makeResultListFuture(java.lang.Iterable,boolean)"><code>makeResultListFuture(Iterable, boolean)</code></a>
 <li><a href="#makeSuccessListFuture(java.lang.Iterable)"><code>makeSuccessListFuture(Iterable)</code></a>
 </ul>
 <p>
 Retry operation and return final result in future:
 <ul>
 <li><a href="#scheduleWhile(org.threadly.concurrent.SubmitterScheduler,long,boolean,java.util.concurrent.Callable,java.util.function.Predicate)"><code>scheduleWhile(SubmitterScheduler, long, boolean, Callable, Predicate)</code></a>
 <li><a href="#scheduleWhile(org.threadly.concurrent.SubmitterScheduler,long,boolean,java.util.concurrent.Callable,java.util.function.Predicate,long,boolean)"><code>scheduleWhile(SubmitterScheduler, long, boolean, Callable, Predicate, long, boolean)</code></a>
 <li><a href="#scheduleWhile(org.threadly.concurrent.SubmitterScheduler,long,org.threadly.concurrent.future.ListenableFuture,java.util.concurrent.Callable,java.util.function.Predicate)"><code>scheduleWhile(SubmitterScheduler, long, ListenableFuture, Callable, Predicate)</code></a>
 <li><a href="#scheduleWhile(org.threadly.concurrent.SubmitterScheduler,long,org.threadly.concurrent.future.ListenableFuture,java.util.concurrent.Callable,java.util.function.Predicate,long,boolean)"><code>scheduleWhile(SubmitterScheduler, long, ListenableFuture, Callable, Predicate, long, boolean)</code></a>
 <li><a href="#scheduleWhile(org.threadly.concurrent.SubmitterScheduler,long,boolean,java.lang.Runnable,java.util.function.Supplier)"><code>scheduleWhile(SubmitterScheduler, long, boolean, Runnable, Supplier)</code></a>
 <li><a href="#scheduleWhile(org.threadly.concurrent.SubmitterScheduler,long,boolean,java.lang.Runnable,java.util.function.Supplier,long)"><code>scheduleWhile(SubmitterScheduler, long, boolean, Runnable, Supplier, long)</code></a>
 <li><a href="#executeWhile(java.util.concurrent.Callable,java.util.function.Predicate)"><code>executeWhile(Callable, Predicate)</code></a>
 <li><a href="#executeWhile(java.util.concurrent.Callable,java.util.function.Predicate,long,boolean)"><code>executeWhile(Callable, Predicate, long, boolean)</code></a>
 <li><a href="#executeWhile(org.threadly.concurrent.future.ListenableFuture,java.util.concurrent.Callable,java.util.function.Predicate)"><code>executeWhile(ListenableFuture, Callable, Predicate)</code></a>
 <li><a href="#executeWhile(org.threadly.concurrent.future.ListenableFuture,java.util.concurrent.Callable,java.util.function.Predicate,long,boolean)"><code>executeWhile(ListenableFuture, Callable, Predicate, long, boolean)</code></a>
 </ul></div>
<dl>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>1.0.0</dd>
</dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="constructor.summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="memberSummary">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Constructor</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr class="altColor">
<th class="colConstructorName" scope="row"><code><span class="memberNameLink"><a href="#%3Cinit%3E()">FutureUtils</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
</table>
</li>
</ul>
</section>
<!-- ========== METHOD SUMMARY =========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t1" class="tableTab"><span><a href="javascript:show(1);">Static Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t6" class="tableTab"><span><a href="javascript:show(32);">Deprecated Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Method</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#blockTillAllComplete(java.lang.Iterable)">blockTillAllComplete</a></span>&#8203;(java.lang.Iterable&lt;? extends java.util.concurrent.Future&lt;?&gt;&gt;&nbsp;futures)</code></th>
<td class="colLast">
<div class="block">This call blocks till all futures in the list have completed.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#blockTillAllComplete(java.lang.Iterable,long)">blockTillAllComplete</a></span>&#8203;(java.lang.Iterable&lt;? extends java.util.concurrent.Future&lt;?&gt;&gt;&nbsp;futures,
                    long&nbsp;timeoutInMillis)</code></th>
<td class="colLast">
<div class="block">This call blocks till all futures in the list have completed.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#blockTillAllCompleteOrFirstError(java.lang.Iterable)">blockTillAllCompleteOrFirstError</a></span>&#8203;(java.lang.Iterable&lt;? extends java.util.concurrent.Future&lt;?&gt;&gt;&nbsp;futures)</code></th>
<td class="colLast">
<div class="block">This call blocks till all futures in the list have completed.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#blockTillAllCompleteOrFirstError(java.lang.Iterable,long)">blockTillAllCompleteOrFirstError</a></span>&#8203;(java.lang.Iterable&lt;? extends java.util.concurrent.Future&lt;?&gt;&gt;&nbsp;futures,
                                long&nbsp;timeoutInMillis)</code></th>
<td class="colLast">
<div class="block">This call blocks till all futures in the list have completed.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#cancelIncompleteFutures(java.lang.Iterable,boolean)">cancelIncompleteFutures</a></span>&#8203;(java.lang.Iterable&lt;? extends java.util.concurrent.Future&lt;?&gt;&gt;&nbsp;futures,
                       boolean&nbsp;interruptThread)</code></th>
<td class="colLast">
<div class="block">Invoked <code>Future.cancel(boolean)</code> for every future in this collection.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#cancelIncompleteFuturesIfAnyFail(boolean,java.lang.Iterable,boolean)">cancelIncompleteFuturesIfAnyFail</a></span>&#8203;(boolean&nbsp;copy,
                                java.lang.Iterable&lt;? extends <a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;?&gt;&gt;&nbsp;futures,
                                boolean&nbsp;interruptThread)</code></th>
<td class="colLast">
<div class="block">Provide a group of futures and cancel all of them if any of them are canceled or fail.</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#countFuturesWithResult(java.lang.Iterable,T)">countFuturesWithResult</a></span>&#8203;(java.lang.Iterable&lt;? extends java.util.concurrent.Future&lt;?&gt;&gt;&nbsp;futures,
                      T&nbsp;comparisonResult)</code></th>
<td class="colLast">
<div class="block">Counts how many futures provided completed with a result that matches the one provided here.</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#countFuturesWithResult(java.lang.Iterable,T,long)">countFuturesWithResult</a></span>&#8203;(java.lang.Iterable&lt;? extends java.util.concurrent.Future&lt;?&gt;&gt;&nbsp;futures,
                      T&nbsp;comparisonResult,
                      long&nbsp;timeoutInMillis)</code></th>
<td class="colLast">
<div class="block">Counts how many futures provided completed with a result that matches the one provided here.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#executeWhile(java.util.concurrent.Callable,java.util.function.Predicate)">executeWhile</a></span>&#8203;(java.util.concurrent.Callable&lt;? extends <a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;? extends T&gt;&gt;&nbsp;asyncTask,
            java.util.function.Predicate&lt;? super T&gt;&nbsp;loopTest)</code></th>
<td class="colLast">
<div class="block">Similar to <a href="#scheduleWhile(org.threadly.concurrent.SubmitterScheduler,long,boolean,java.util.concurrent.Callable,java.util.function.Predicate)"><code>scheduleWhile(SubmitterScheduler, long, boolean, Callable, Predicate)</code></a> 
 except that no executor is needed because the callable instead will return a future from the 
 provided async submission (which may be a scheduled task or otherwise).</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#executeWhile(java.util.concurrent.Callable,java.util.function.Predicate,long,boolean)">executeWhile</a></span>&#8203;(java.util.concurrent.Callable&lt;? extends <a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;? extends T&gt;&gt;&nbsp;asyncTask,
            java.util.function.Predicate&lt;? super T&gt;&nbsp;loopTest,
            long&nbsp;timeoutMillis,
            boolean&nbsp;timeoutProvideLastValue)</code></th>
<td class="colLast">
<div class="block">Similar to <a href="#scheduleWhile(org.threadly.concurrent.SubmitterScheduler,long,boolean,java.util.concurrent.Callable,java.util.function.Predicate,long,boolean)"><code>scheduleWhile(SubmitterScheduler, long, boolean, Callable, Predicate, long, boolean)</code></a> 
 except that no executor is needed because the callable instead will return a future from the 
 provided async submission (which may be a scheduled task or otherwise).</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#executeWhile(org.threadly.concurrent.future.ListenableFuture,java.util.concurrent.Callable,java.util.function.Predicate)">executeWhile</a></span>&#8203;(<a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;? extends T&gt;&nbsp;startingFuture,
            java.util.concurrent.Callable&lt;? extends <a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;? extends T&gt;&gt;&nbsp;asyncTask,
            java.util.function.Predicate&lt;? super T&gt;&nbsp;loopTest)</code></th>
<td class="colLast">
<div class="block">Similar to <a href="#scheduleWhile(org.threadly.concurrent.SubmitterScheduler,long,org.threadly.concurrent.future.ListenableFuture,java.util.concurrent.Callable,java.util.function.Predicate)"><code>scheduleWhile(SubmitterScheduler, long, ListenableFuture, Callable, Predicate)</code></a> 
 except that no executor is needed because the callable instead will return a future from the 
 provided async submission (which may be a scheduled task or otherwise).</div>
</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#executeWhile(org.threadly.concurrent.future.ListenableFuture,java.util.concurrent.Callable,java.util.function.Predicate,long,boolean)">executeWhile</a></span>&#8203;(<a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;? extends T&gt;&nbsp;startingFuture,
            java.util.concurrent.Callable&lt;? extends <a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;? extends T&gt;&gt;&nbsp;asyncTask,
            java.util.function.Predicate&lt;? super T&gt;&nbsp;loopTest,
            long&nbsp;timeoutMillis,
            boolean&nbsp;lastValueOnTimeout)</code></th>
<td class="colLast">
<div class="block">Similar to <a href="#scheduleWhile(org.threadly.concurrent.SubmitterScheduler,long,org.threadly.concurrent.future.ListenableFuture,java.util.concurrent.Callable,java.util.function.Predicate,long,boolean)"><code>scheduleWhile(SubmitterScheduler, long, ListenableFuture, Callable, Predicate, long, boolean)</code></a> 
 except that no executor is needed because the callable instead will return a future from the 
 provided async submission (which may be a scheduled task or otherwise).</div>
</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#immediateFailureFuture(java.lang.Throwable)">immediateFailureFuture</a></span>&#8203;(java.lang.Throwable&nbsp;failure)</code></th>
<td class="colLast">
<div class="block">Constructs a <a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future"><code>ListenableFuture</code></a> that has failed with the given failure.</div>
</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#immediateResultFuture(T)">immediateResultFuture</a></span>&#8203;(T&nbsp;result)</code></th>
<td class="colLast">
<div class="block">Constructs a <a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future"><code>ListenableFuture</code></a> that has already had the provided result given to it.</div>
</td>
</tr>
<tr id="i14" class="altColor">
<td class="colFirst"><code>static <a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;?&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#makeCompleteFuture(java.lang.Iterable)">makeCompleteFuture</a></span>&#8203;(java.lang.Iterable&lt;? extends <a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;?&gt;&gt;&nbsp;futures)</code></th>
<td class="colLast">
<div class="block">An alternative to <a href="#blockTillAllComplete(java.lang.Iterable)"><code>blockTillAllComplete(Iterable)</code></a>, this provides the ability to know 
 when all futures are complete without blocking.</div>
</td>
</tr>
<tr id="i15" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#makeCompleteFuture(java.lang.Iterable,T)">makeCompleteFuture</a></span>&#8203;(java.lang.Iterable&lt;? extends <a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;?&gt;&gt;&nbsp;futures,
                  T&nbsp;result)</code></th>
<td class="colLast">
<div class="block">An alternative to <a href="#blockTillAllComplete(java.lang.Iterable)"><code>blockTillAllComplete(Iterable)</code></a>, this provides the ability to know 
 when all futures are complete without blocking.</div>
</td>
</tr>
<tr id="i16" class="altColor">
<td class="colFirst"><code>static <a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;?&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#makeCompleteFuture(java.util.List)">makeCompleteFuture</a></span>&#8203;(java.util.List&lt;? extends <a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;?&gt;&gt;&nbsp;futures)</code></th>
<td class="colLast">
<div class="block">An alternative to <a href="#blockTillAllComplete(java.lang.Iterable)"><code>blockTillAllComplete(Iterable)</code></a>, this provides the ability to know 
 when all futures are complete without blocking.</div>
</td>
</tr>
<tr id="i17" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;java.util.List&lt;<a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;? extends T&gt;&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#makeCompleteListFuture(java.lang.Iterable)">makeCompleteListFuture</a></span>&#8203;(java.lang.Iterable&lt;? extends <a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;? extends T&gt;&gt;&nbsp;futures)</code></th>
<td class="colLast">
<div class="block">This call is similar to <a href="#makeCompleteFuture(java.lang.Iterable)"><code>makeCompleteFuture(Iterable)</code></a> in that it will immediately 
 provide a future that will not be satisfied till all provided futures complete.</div>
</td>
</tr>
<tr id="i18" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;java.util.List&lt;<a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;? extends T&gt;&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#makeFailureListFuture(java.lang.Iterable)">makeFailureListFuture</a></span>&#8203;(java.lang.Iterable&lt;? extends <a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;? extends T&gt;&gt;&nbsp;futures)</code></th>
<td class="colLast">
<div class="block">This call is similar to <a href="#makeCompleteFuture(java.lang.Iterable)"><code>makeCompleteFuture(Iterable)</code></a> in that it will immediately 
 provide a future that will not be satisfied till all provided futures complete.</div>
</td>
</tr>
<tr id="i19" class="rowColor">
<td class="colFirst"><code>static <a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;?&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#makeFailurePropagatingCompleteFuture(java.lang.Iterable)">makeFailurePropagatingCompleteFuture</a></span>&#8203;(java.lang.Iterable&lt;? extends <a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;?&gt;&gt;&nbsp;futures)</code></th>
<td class="colLast">
<div class="block">Similar to <a href="#makeCompleteFuture(java.lang.Iterable)"><code>makeCompleteFuture(Iterable)</code></a> in that the returned future wont complete 
 until all the provided futures complete.</div>
</td>
</tr>
<tr id="i20" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#makeFailurePropagatingCompleteFuture(java.lang.Iterable,T)">makeFailurePropagatingCompleteFuture</a></span>&#8203;(java.lang.Iterable&lt;? extends <a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;?&gt;&gt;&nbsp;futures,
                                    T&nbsp;result)</code></th>
<td class="colLast">
<div class="block">Similar to <a href="#makeCompleteFuture(java.lang.Iterable,T)"><code>makeCompleteFuture(Iterable, Object)</code></a> in that the returned future wont 
 complete until all the provided futures complete.</div>
</td>
</tr>
<tr id="i21" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;java.util.List&lt;T&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#makeResultListFuture(java.lang.Iterable,boolean)">makeResultListFuture</a></span>&#8203;(java.lang.Iterable&lt;? extends <a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;? extends T&gt;&gt;&nbsp;futures,
                    boolean&nbsp;ignoreFailedFutures)</code></th>
<td class="colLast">
<div class="block">This returns a future which provides the results of all the provided futures.</div>
</td>
</tr>
<tr id="i22" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;java.util.List&lt;<a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;? extends T&gt;&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#makeSuccessListFuture(java.lang.Iterable)">makeSuccessListFuture</a></span>&#8203;(java.lang.Iterable&lt;? extends <a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;? extends T&gt;&gt;&nbsp;futures)</code></th>
<td class="colLast">
<div class="block">This call is similar to <a href="#makeCompleteFuture(java.lang.Iterable)"><code>makeCompleteFuture(Iterable)</code></a> in that it will immediately 
 provide a future that will not be satisfied till all provided futures complete.</div>
</td>
</tr>
<tr id="i23" class="rowColor">
<td class="colFirst"><code>static <a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;?&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#scheduleWhile(org.threadly.concurrent.SubmitterScheduler,long,boolean,java.lang.Runnable,java.util.function.Supplier)">scheduleWhile</a></span>&#8203;(<a href="../SubmitterScheduler.html" title="interface in org.threadly.concurrent">SubmitterScheduler</a>&nbsp;scheduler,
             long&nbsp;scheduleDelayMillis,
             boolean&nbsp;firstRunAsync,
             java.lang.Runnable&nbsp;task,
             java.util.function.Supplier&lt;java.lang.Boolean&gt;&nbsp;loopTest)</code></th>
<td class="colLast">
<div class="block">Executes a task until the provided supplier returns <code>false</code>.</div>
</td>
</tr>
<tr id="i24" class="altColor">
<td class="colFirst"><code>static <a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;?&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#scheduleWhile(org.threadly.concurrent.SubmitterScheduler,long,boolean,java.lang.Runnable,java.util.function.Supplier,long)">scheduleWhile</a></span>&#8203;(<a href="../SubmitterScheduler.html" title="interface in org.threadly.concurrent">SubmitterScheduler</a>&nbsp;scheduler,
             long&nbsp;scheduleDelayMillis,
             boolean&nbsp;firstRunAsync,
             java.lang.Runnable&nbsp;task,
             java.util.function.Supplier&lt;java.lang.Boolean&gt;&nbsp;loopTest,
             long&nbsp;timeoutMillis)</code></th>
<td class="colLast">
<div class="block">Executes a task, checking the result from the task to see if it needs to reschedule the task 
 again.</div>
</td>
</tr>
<tr id="i25" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#scheduleWhile(org.threadly.concurrent.SubmitterScheduler,long,boolean,java.util.concurrent.Callable,java.util.function.Predicate)">scheduleWhile</a></span>&#8203;(<a href="../SubmitterScheduler.html" title="interface in org.threadly.concurrent">SubmitterScheduler</a>&nbsp;scheduler,
             long&nbsp;scheduleDelayMillis,
             boolean&nbsp;firstRunAsync,
             java.util.concurrent.Callable&lt;? extends T&gt;&nbsp;task,
             java.util.function.Predicate&lt;? super T&gt;&nbsp;loopTest)</code></th>
<td class="colLast">
<div class="block">Executes a task, checking the result from the task to see if it needs to reschedule the task 
 again.</div>
</td>
</tr>
<tr id="i26" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#scheduleWhile(org.threadly.concurrent.SubmitterScheduler,long,boolean,java.util.concurrent.Callable,java.util.function.Predicate,long,boolean)">scheduleWhile</a></span>&#8203;(<a href="../SubmitterScheduler.html" title="interface in org.threadly.concurrent">SubmitterScheduler</a>&nbsp;scheduler,
             long&nbsp;scheduleDelayMillis,
             boolean&nbsp;firstRunAsync,
             java.util.concurrent.Callable&lt;? extends T&gt;&nbsp;task,
             java.util.function.Predicate&lt;? super T&gt;&nbsp;loopTest,
             long&nbsp;timeoutMillis,
             boolean&nbsp;timeoutProvideLastValue)</code></th>
<td class="colLast">
<div class="block">Executes a task, checking the result from the task to see if it needs to reschedule the task 
 again.</div>
</td>
</tr>
<tr id="i27" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#scheduleWhile(org.threadly.concurrent.SubmitterScheduler,long,org.threadly.concurrent.future.ListenableFuture,java.util.concurrent.Callable,java.util.function.Predicate)">scheduleWhile</a></span>&#8203;(<a href="../SubmitterScheduler.html" title="interface in org.threadly.concurrent">SubmitterScheduler</a>&nbsp;scheduler,
             long&nbsp;scheduleDelayMillis,
             <a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;? extends T&gt;&nbsp;startingFuture,
             java.util.concurrent.Callable&lt;? extends T&gt;&nbsp;task,
             java.util.function.Predicate&lt;? super T&gt;&nbsp;loopTest)</code></th>
<td class="colLast">
<div class="block">Executes a task, checking the result from the task to see if it needs to reschedule the task 
 again.</div>
</td>
</tr>
<tr id="i28" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#scheduleWhile(org.threadly.concurrent.SubmitterScheduler,long,org.threadly.concurrent.future.ListenableFuture,java.util.concurrent.Callable,java.util.function.Predicate,long,boolean)">scheduleWhile</a></span>&#8203;(<a href="../SubmitterScheduler.html" title="interface in org.threadly.concurrent">SubmitterScheduler</a>&nbsp;scheduler,
             long&nbsp;scheduleDelayMillis,
             <a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;? extends T&gt;&nbsp;startingFuture,
             java.util.concurrent.Callable&lt;? extends T&gt;&nbsp;task,
             java.util.function.Predicate&lt;? super T&gt;&nbsp;loopTest,
             long&nbsp;timeoutMillis,
             boolean&nbsp;timeoutProvideLastValue)</code></th>
<td class="colLast">
<div class="block">Executes a task, checking the result from the task to see if it needs to reschedule the task 
 again.</div>
</td>
</tr>
<tr id="i29" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#scheduleWhileTaskResultNull(org.threadly.concurrent.SubmitterScheduler,long,boolean,java.util.concurrent.Callable)">scheduleWhileTaskResultNull</a></span>&#8203;(<a href="../SubmitterScheduler.html" title="interface in org.threadly.concurrent">SubmitterScheduler</a>&nbsp;scheduler,
                           long&nbsp;scheduleDelayMillis,
                           boolean&nbsp;firstRunAsync,
                           java.util.concurrent.Callable&lt;? extends T&gt;&nbsp;task)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Please use <a href="#scheduleWhile(org.threadly.concurrent.SubmitterScheduler,long,boolean,java.util.concurrent.Callable,java.util.function.Predicate)"><code>scheduleWhile(SubmitterScheduler, long, boolean, Callable, Predicate)</code></a></div>
</div>
</td>
</tr>
<tr id="i30" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#scheduleWhileTaskResultNull(org.threadly.concurrent.SubmitterScheduler,long,boolean,java.util.concurrent.Callable,long)">scheduleWhileTaskResultNull</a></span>&#8203;(<a href="../SubmitterScheduler.html" title="interface in org.threadly.concurrent">SubmitterScheduler</a>&nbsp;scheduler,
                           long&nbsp;scheduleDelayMillis,
                           boolean&nbsp;firstRunAsync,
                           java.util.concurrent.Callable&lt;? extends T&gt;&nbsp;task,
                           long&nbsp;timeoutMillis)</code></th>
<td class="colLast">
<div class="block"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Please use with a simple null checking Predicate
               <a href="#scheduleWhile(org.threadly.concurrent.SubmitterScheduler,long,boolean,java.util.concurrent.Callable,java.util.function.Predicate,long,boolean)"><code>scheduleWhile(SubmitterScheduler, long, boolean, Callable, Predicate, long, boolean)</code></a></div>
</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>equals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="constructor.detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a id="&lt;init&gt;()">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>FutureUtils</h4>
<pre>public&nbsp;FutureUtils()</pre>
</li>
</ul>
</li>
</ul>
</section>
<!-- ============ METHOD DETAIL ========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a id="blockTillAllComplete(java.lang.Iterable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>blockTillAllComplete</h4>
<pre class="methodSignature">public static&nbsp;void&nbsp;blockTillAllComplete&#8203;(java.lang.Iterable&lt;? extends java.util.concurrent.Future&lt;?&gt;&gt;&nbsp;futures)
                                 throws java.lang.InterruptedException</pre>
<div class="block">This call blocks till all futures in the list have completed.  If the future completed with 
 an error, the <code>ExecutionException</code> is swallowed.  Meaning that this does not attempt to 
 verify that all futures completed successfully.  If you need to know if any failed, please 
 use <a href="#blockTillAllCompleteOrFirstError(java.lang.Iterable)"><code>blockTillAllCompleteOrFirstError(Iterable)</code></a>.  
 <p>
 If you need to specify a timeout to control how long to block, consider using 
 <a href="#blockTillAllComplete(java.lang.Iterable,long)"><code>blockTillAllComplete(Iterable, long)</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>futures</code> - Structure of futures to iterate over</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.InterruptedException</code> - Thrown if thread is interrupted while waiting on future</dd>
</dl>
</li>
</ul>
<a id="blockTillAllComplete(java.lang.Iterable,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>blockTillAllComplete</h4>
<pre class="methodSignature">public static&nbsp;void&nbsp;blockTillAllComplete&#8203;(java.lang.Iterable&lt;? extends java.util.concurrent.Future&lt;?&gt;&gt;&nbsp;futures,
                                        long&nbsp;timeoutInMillis)
                                 throws java.lang.InterruptedException,
                                        java.util.concurrent.TimeoutException</pre>
<div class="block">This call blocks till all futures in the list have completed.  If the future completed with 
 an error, the <code>ExecutionException</code> is swallowed.  Meaning that this does not attempt to 
 verify that all futures completed successfully.  If you need to know if any failed, please 
 use <a href="#blockTillAllCompleteOrFirstError(java.lang.Iterable,long)"><code>blockTillAllCompleteOrFirstError(Iterable, long)</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>futures</code> - Structure of futures to iterate over</dd>
<dd><code>timeoutInMillis</code> - timeout to wait for futures to complete in milliseconds</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.InterruptedException</code> - Thrown if thread is interrupted while waiting on future</dd>
<dd><code>java.util.concurrent.TimeoutException</code> - Thrown if the timeout elapsed while waiting on futures to complete</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>4.0.0</dd>
</dl>
</li>
</ul>
<a id="blockTillAllCompleteOrFirstError(java.lang.Iterable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>blockTillAllCompleteOrFirstError</h4>
<pre class="methodSignature">public static&nbsp;void&nbsp;blockTillAllCompleteOrFirstError&#8203;(java.lang.Iterable&lt;? extends java.util.concurrent.Future&lt;?&gt;&gt;&nbsp;futures)
                                             throws java.lang.InterruptedException,
                                                    java.util.concurrent.ExecutionException</pre>
<div class="block">This call blocks till all futures in the list have completed.  If the future completed with 
 an error an <code>ExecutionException</code> is thrown.  If this exception is thrown, all futures 
 may or may not be completed, the exception is thrown as soon as it is hit.  There also may be 
 additional futures that errored (but were not hit yet).  
 <p>
 If you need to specify a timeout to control how long to block, consider using 
 <a href="#blockTillAllCompleteOrFirstError(java.lang.Iterable,long)"><code>blockTillAllCompleteOrFirstError(Iterable, long)</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>futures</code> - Structure of futures to iterate over</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.InterruptedException</code> - Thrown if thread is interrupted while waiting on future</dd>
<dd><code>java.util.concurrent.ExecutionException</code> - Thrown if future throws exception on .get() call</dd>
</dl>
</li>
</ul>
<a id="blockTillAllCompleteOrFirstError(java.lang.Iterable,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>blockTillAllCompleteOrFirstError</h4>
<pre class="methodSignature">public static&nbsp;void&nbsp;blockTillAllCompleteOrFirstError&#8203;(java.lang.Iterable&lt;? extends java.util.concurrent.Future&lt;?&gt;&gt;&nbsp;futures,
                                                    long&nbsp;timeoutInMillis)
                                             throws java.lang.InterruptedException,
                                                    java.util.concurrent.TimeoutException,
                                                    java.util.concurrent.ExecutionException</pre>
<div class="block">This call blocks till all futures in the list have completed.  If the future completed with 
 an error an <code>ExecutionException</code> is thrown.  If this exception is thrown, all futures 
 may or may not be completed, the exception is thrown as soon as it is hit.  There also may be 
 additional futures that errored (but were not hit yet).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>futures</code> - Structure of futures to iterate over</dd>
<dd><code>timeoutInMillis</code> - timeout to wait for futures to complete in milliseconds</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.InterruptedException</code> - Thrown if thread is interrupted while waiting on future</dd>
<dd><code>java.util.concurrent.TimeoutException</code> - Thrown if the timeout elapsed while waiting on futures to complete</dd>
<dd><code>java.util.concurrent.ExecutionException</code> - Thrown if future throws exception on .get() call</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>4.0.0</dd>
</dl>
</li>
</ul>
<a id="countFuturesWithResult(java.lang.Iterable,java.lang.Object)">
<!--   -->
</a><a id="countFuturesWithResult(java.lang.Iterable,T)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>countFuturesWithResult</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;int&nbsp;countFuturesWithResult&#8203;(java.lang.Iterable&lt;? extends java.util.concurrent.Future&lt;?&gt;&gt;&nbsp;futures,
                                             T&nbsp;comparisonResult)
                                      throws java.lang.InterruptedException</pre>
<div class="block">Counts how many futures provided completed with a result that matches the one provided here.  
 This can be most useful if your looking to know if an error occurred that was not an 
 <code>ExecutionException</code>.  For example assume an API return's <code>Future&lt;Boolean&gt;</code> and a 
 <code>false</code> represents a failure, this can be used to look for those types of error 
 results.  
 <p>
 Just like <a href="#blockTillAllComplete(java.lang.Iterable)"><code>blockTillAllComplete(Iterable)</code></a>, this will block until all futures have 
 completed (so we can verify if their result matches or not).  
 <p>
 If you need to specify a timeout to control how long to block, consider using 
 <a href="#countFuturesWithResult(java.lang.Iterable,T,long)"><code>countFuturesWithResult(Iterable, Object, long)</code></a>.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - type of result futures provide to compare against</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>futures</code> - Structure of futures to iterate over</dd>
<dd><code>comparisonResult</code> - Object to compare future results against to look for match</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Number of futures which match the result using a <code>Object.equals(Object)</code> comparison</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.InterruptedException</code> - Thrown if thread is interrupted while waiting on future's result</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>4.0.0</dd>
</dl>
</li>
</ul>
<a id="countFuturesWithResult(java.lang.Iterable,java.lang.Object,long)">
<!--   -->
</a><a id="countFuturesWithResult(java.lang.Iterable,T,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>countFuturesWithResult</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;int&nbsp;countFuturesWithResult&#8203;(java.lang.Iterable&lt;? extends java.util.concurrent.Future&lt;?&gt;&gt;&nbsp;futures,
                                             T&nbsp;comparisonResult,
                                             long&nbsp;timeoutInMillis)
                                      throws java.lang.InterruptedException,
                                             java.util.concurrent.TimeoutException</pre>
<div class="block">Counts how many futures provided completed with a result that matches the one provided here.  
 This can be most useful if your looking to know if an error occurred that was not an 
 <code>ExecutionException</code>.  For example assume an API return's <code>Future&lt;Boolean&gt;</code> and a 
 <code>false</code> represents a failure, this can be used to look for those types of error 
 results.  
 <p>
 Just like <a href="#blockTillAllComplete(java.lang.Iterable)"><code>blockTillAllComplete(Iterable)</code></a>, this will block until all futures have 
 completed (so we can verify if their result matches or not).</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - type of result futures provide to compare against</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>futures</code> - Structure of futures to iterate over</dd>
<dd><code>comparisonResult</code> - Object to compare future results against to look for match</dd>
<dd><code>timeoutInMillis</code> - timeout to wait for futures to complete in milliseconds</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Number of futures which match the result using a <code>Object.equals(Object)</code> comparison</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.InterruptedException</code> - Thrown if thread is interrupted while waiting on future's result</dd>
<dd><code>java.util.concurrent.TimeoutException</code> - Thrown if the timeout elapsed while waiting on futures to complete</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>4.0.0</dd>
</dl>
</li>
</ul>
<a id="makeCompleteFuture(java.util.List)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>makeCompleteFuture</h4>
<pre class="methodSignature">public static&nbsp;<a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;?&gt;&nbsp;makeCompleteFuture&#8203;(java.util.List&lt;? extends <a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;?&gt;&gt;&nbsp;futures)</pre>
<div class="block">An alternative to <a href="#blockTillAllComplete(java.lang.Iterable)"><code>blockTillAllComplete(Iterable)</code></a>, this provides the ability to know 
 when all futures are complete without blocking.  Unlike 
 <a href="#blockTillAllComplete(java.lang.Iterable)"><code>blockTillAllComplete(Iterable)</code></a>, this requires that you provide a collection of 
 <a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future"><code>ListenableFuture</code></a>'s.  But will return immediately, providing a new 
 <a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future"><code>ListenableFuture</code></a> that will be called once all the provided futures have finished.  
 <p>
 The future returned will provide a <code>null</code> result, it is the responsibility of the 
 caller to get the actual results from the provided futures.  This is designed to just be an 
 indicator as to when they have finished.  If you need the results from the provided futures, 
 consider using <a href="#makeCompleteListFuture(java.lang.Iterable)"><code>makeCompleteListFuture(Iterable)</code></a>.  You should also consider using 
 <a href="#makeFailurePropagatingCompleteFuture(java.lang.Iterable)"><code>makeFailurePropagatingCompleteFuture(Iterable)</code></a>, it has the same semantics as this one 
 except it will put the returned future into an error state if any of the provided futures error.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>futures</code> - Collection of futures that must finish before returned future is satisfied</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>ListenableFuture which will be done once all futures provided are done</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>5.3</dd>
</dl>
</li>
</ul>
<a id="makeCompleteFuture(java.lang.Iterable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>makeCompleteFuture</h4>
<pre class="methodSignature">public static&nbsp;<a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;?&gt;&nbsp;makeCompleteFuture&#8203;(java.lang.Iterable&lt;? extends <a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;?&gt;&gt;&nbsp;futures)</pre>
<div class="block">An alternative to <a href="#blockTillAllComplete(java.lang.Iterable)"><code>blockTillAllComplete(Iterable)</code></a>, this provides the ability to know 
 when all futures are complete without blocking.  Unlike 
 <a href="#blockTillAllComplete(java.lang.Iterable)"><code>blockTillAllComplete(Iterable)</code></a>, this requires that you provide a collection of 
 <a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future"><code>ListenableFuture</code></a>'s.  But will return immediately, providing a new 
 <a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future"><code>ListenableFuture</code></a> that will be called once all the provided futures have finished.  
 <p>
 The future returned will provide a <code>null</code> result, it is the responsibility of the 
 caller to get the actual results from the provided futures.  This is designed to just be an 
 indicator as to when they have finished.  If you need the results from the provided futures, 
 consider using <a href="#makeCompleteListFuture(java.lang.Iterable)"><code>makeCompleteListFuture(Iterable)</code></a>.  You should also consider using 
 <a href="#makeFailurePropagatingCompleteFuture(java.lang.Iterable)"><code>makeFailurePropagatingCompleteFuture(Iterable)</code></a>, it has the same semantics as this one 
 except it will put the returned future into an error state if any of the provided futures error.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>futures</code> - Collection of futures that must finish before returned future is satisfied</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>ListenableFuture which will be done once all futures provided are done</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>1.2.0</dd>
</dl>
</li>
</ul>
<a id="makeCompleteFuture(java.lang.Iterable,java.lang.Object)">
<!--   -->
</a><a id="makeCompleteFuture(java.lang.Iterable,T)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>makeCompleteFuture</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;T&gt;&nbsp;makeCompleteFuture&#8203;(java.lang.Iterable&lt;? extends <a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;?&gt;&gt;&nbsp;futures,
                                                         T&nbsp;result)</pre>
<div class="block">An alternative to <a href="#blockTillAllComplete(java.lang.Iterable)"><code>blockTillAllComplete(Iterable)</code></a>, this provides the ability to know 
 when all futures are complete without blocking.  Unlike 
 <a href="#blockTillAllComplete(java.lang.Iterable)"><code>blockTillAllComplete(Iterable)</code></a>, this requires that you provide a collection of 
 <a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future"><code>ListenableFuture</code></a>'s.  But will return immediately, providing a new 
 <a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future"><code>ListenableFuture</code></a> that will be called once all the provided futures have finished.  
 <p>
 The future returned will provide the result object once all provided futures have completed.  
 If any failures occured, they will not be represented in the returned future.  If that is 
 desired you should consider using 
 <a href="#makeFailurePropagatingCompleteFuture(java.lang.Iterable,T)"><code>makeFailurePropagatingCompleteFuture(Iterable, Object)</code></a>, it has the same semantics as 
 this one except it will put the returned future into an error state if any of the provided 
 futures error.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - type of result returned from the future</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>futures</code> - Collection of futures that must finish before returned future is satisfied</dd>
<dd><code>result</code> - Result to provide returned future once all futures complete</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>ListenableFuture which will be done once all futures provided are done</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>3.3.0</dd>
</dl>
</li>
</ul>
<a id="makeFailurePropagatingCompleteFuture(java.lang.Iterable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>makeFailurePropagatingCompleteFuture</h4>
<pre class="methodSignature">public static&nbsp;<a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;?&gt;&nbsp;makeFailurePropagatingCompleteFuture&#8203;(java.lang.Iterable&lt;? extends <a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;?&gt;&gt;&nbsp;futures)</pre>
<div class="block">Similar to <a href="#makeCompleteFuture(java.lang.Iterable)"><code>makeCompleteFuture(Iterable)</code></a> in that the returned future wont complete 
 until all the provided futures complete.  However this implementation will check if any 
 futures failed or were canceled once all have completed.  If any did not complete normally 
 then the returned futures state will match the state of one of the futures that did not 
 normally (randomly chosen).
 <p>
 Since the returned future wont complete until all futures complete, you may want to consider 
 using <a href="#cancelIncompleteFuturesIfAnyFail(boolean,java.lang.Iterable,boolean)"><code>cancelIncompleteFuturesIfAnyFail(boolean, Iterable, boolean)</code></a> in addition to 
 this so that the future will resolve as soon as any failures occur.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>futures</code> - Collection of futures that must finish before returned future is satisfied</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>ListenableFuture which will be done once all futures provided are done</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>5.0</dd>
</dl>
</li>
</ul>
<a id="makeFailurePropagatingCompleteFuture(java.lang.Iterable,java.lang.Object)">
<!--   -->
</a><a id="makeFailurePropagatingCompleteFuture(java.lang.Iterable,T)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>makeFailurePropagatingCompleteFuture</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;T&gt;&nbsp;makeFailurePropagatingCompleteFuture&#8203;(java.lang.Iterable&lt;? extends <a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;?&gt;&gt;&nbsp;futures,
                                                                           T&nbsp;result)</pre>
<div class="block">Similar to <a href="#makeCompleteFuture(java.lang.Iterable,T)"><code>makeCompleteFuture(Iterable, Object)</code></a> in that the returned future wont 
 complete until all the provided futures complete.  However this implementation will check if 
 any futures failed or were canceled once all have completed.  If any did not complete normally 
 then the returned futures state will match the state of one of the futures that did not 
 normally (randomly chosen).
 <p>
 Since the returned future wont complete until all futures complete, you may want to consider 
 using <a href="#cancelIncompleteFuturesIfAnyFail(boolean,java.lang.Iterable,boolean)"><code>cancelIncompleteFuturesIfAnyFail(boolean, Iterable, boolean)</code></a> in addition to 
 this so that the future will resolve as soon as any failures occur.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - type of result returned from the future</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>futures</code> - Collection of futures that must finish before returned future is satisfied</dd>
<dd><code>result</code> - Result to provide returned future once all futures complete</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>ListenableFuture which will be done once all futures provided are done</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>5.0</dd>
</dl>
</li>
</ul>
<a id="makeCompleteListFuture(java.lang.Iterable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>makeCompleteListFuture</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;java.util.List&lt;<a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;? extends T&gt;&gt;&gt;&nbsp;makeCompleteListFuture&#8203;(java.lang.Iterable&lt;? extends <a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;? extends T&gt;&gt;&nbsp;futures)</pre>
<div class="block">This call is similar to <a href="#makeCompleteFuture(java.lang.Iterable)"><code>makeCompleteFuture(Iterable)</code></a> in that it will immediately 
 provide a future that will not be satisfied till all provided futures complete.  
 <p>
 This future provides a list of the completed futures as the result.  The order of the result 
 list will match the order returned by the provided <code>Iterable</code>.
 <p>
 If <code>Future.cancel(boolean)</code> is invoked on the returned future, all provided 
 futures will attempt to be canceled in the same way.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - The result object type returned from the futures</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>futures</code> - Structure of futures to iterate over</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>ListenableFuture which will be done once all futures provided are done</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>1.2.0</dd>
</dl>
</li>
</ul>
<a id="makeSuccessListFuture(java.lang.Iterable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>makeSuccessListFuture</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;java.util.List&lt;<a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;? extends T&gt;&gt;&gt;&nbsp;makeSuccessListFuture&#8203;(java.lang.Iterable&lt;? extends <a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;? extends T&gt;&gt;&nbsp;futures)</pre>
<div class="block">This call is similar to <a href="#makeCompleteFuture(java.lang.Iterable)"><code>makeCompleteFuture(Iterable)</code></a> in that it will immediately 
 provide a future that will not be satisfied till all provided futures complete.  
 <p>
 This future provides a list of the futures that completed without throwing an exception nor 
 were canceled.  The order of the resulting list is NOT deterministic.  If order is needed 
 please see <a href="#makeCompleteListFuture(java.lang.Iterable)"><code>makeCompleteListFuture(Iterable)</code></a> and check for results.
 <p>
 If <code>Future.cancel(boolean)</code> is invoked on the returned future, all provided 
 futures will attempt to be canceled in the same way.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - The result object type returned from the futures</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>futures</code> - Structure of futures to iterate over</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>ListenableFuture which will be done once all futures provided are done</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>1.2.0</dd>
</dl>
</li>
</ul>
<a id="makeFailureListFuture(java.lang.Iterable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>makeFailureListFuture</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;java.util.List&lt;<a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;? extends T&gt;&gt;&gt;&nbsp;makeFailureListFuture&#8203;(java.lang.Iterable&lt;? extends <a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;? extends T&gt;&gt;&nbsp;futures)</pre>
<div class="block">This call is similar to <a href="#makeCompleteFuture(java.lang.Iterable)"><code>makeCompleteFuture(Iterable)</code></a> in that it will immediately 
 provide a future that will not be satisfied till all provided futures complete.  
 <p>
 This future provides a list of the futures that failed by either throwing an exception or 
 were canceled.  The order of the resulting list is NOT deterministic.  If order is needed 
 please see <a href="#makeCompleteListFuture(java.lang.Iterable)"><code>makeCompleteListFuture(Iterable)</code></a> and check for results.
 <p>
 If <code>Future.cancel(boolean)</code> is invoked on the returned future, all provided 
 futures will attempt to be canceled in the same way.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - The result object type returned from the futures</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>futures</code> - Structure of futures to iterate over</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>ListenableFuture which will be done once all futures provided are done</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>1.2.0</dd>
</dl>
</li>
</ul>
<a id="makeResultListFuture(java.lang.Iterable,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>makeResultListFuture</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;java.util.List&lt;T&gt;&gt;&nbsp;makeResultListFuture&#8203;(java.lang.Iterable&lt;? extends <a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;? extends T&gt;&gt;&nbsp;futures,
                                                                           boolean&nbsp;ignoreFailedFutures)</pre>
<div class="block">This returns a future which provides the results of all the provided futures.  Thus 
 preventing the need to iterate over all the futures and manually extract the results.  This 
 call does NOT block, instead it will return a future which will not complete until all the 
 provided futures complete.  
 <p>
 The order of the result list will match the order returned by the provided <code>Iterable</code>.
 <p>
 If called with <code>true</code> for <code>ignoreFailedFutures</code>, even if some of the provided 
 futures finished in error, they will be ignored and just the successful results will be 
 provided.  If called with <code>false</code> then if any futures complete in error, then the 
 returned future will throw a <code>ExecutionException</code> with the error as the cause when 
 <code>Future.get()</code> is invoked.  In addition if called with <code>false</code> and any of the 
 provided futures are canceled, then the returned future will also be canceled, resulting in a 
 <code>CancellationException</code> being thrown when <code>Future.get()</code> is invoked.  In the case 
 where there is canceled and failed exceptions in the collection, this will prefer to throw the 
 failure as an <code>ExecutionException</code> rather than obscure it with a 
 <code>CancellationException</code>.  In other words <code>CancellationException</code> will be thrown 
 ONLY if there was canceled tasks, but NO tasks which finished in error.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - The result object type returned from the futures</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>futures</code> - Structure of futures to iterate over and extract results from</dd>
<dd><code>ignoreFailedFutures</code> - <code>true</code> to ignore any failed or canceled futures</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future"><code>ListenableFuture</code></a> which will provide a list of the results from the provided futures</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>4.0.0</dd>
</dl>
</li>
</ul>
<a id="cancelIncompleteFutures(java.lang.Iterable,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>cancelIncompleteFutures</h4>
<pre class="methodSignature">public static&nbsp;void&nbsp;cancelIncompleteFutures&#8203;(java.lang.Iterable&lt;? extends java.util.concurrent.Future&lt;?&gt;&gt;&nbsp;futures,
                                           boolean&nbsp;interruptThread)</pre>
<div class="block">Invoked <code>Future.cancel(boolean)</code> for every future in this collection.  Thus if there 
 are any futures which have not already completed, they will now be marked as canceled.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>futures</code> - Collection of futures to iterate through and cancel</dd>
<dd><code>interruptThread</code> - Valued passed in to interrupt thread when calling <code>Future.cancel(boolean)</code></dd>
</dl>
</li>
</ul>
<a id="cancelIncompleteFuturesIfAnyFail(boolean,java.lang.Iterable,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>cancelIncompleteFuturesIfAnyFail</h4>
<pre class="methodSignature">public static&nbsp;void&nbsp;cancelIncompleteFuturesIfAnyFail&#8203;(boolean&nbsp;copy,
                                                    java.lang.Iterable&lt;? extends <a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;?&gt;&gt;&nbsp;futures,
                                                    boolean&nbsp;interruptThread)</pre>
<div class="block">Provide a group of futures and cancel all of them if any of them are canceled or fail.  
 <p>
 If <code>false</code> is provided for <code>copy</code> parameter, then <code>futures</code> will be 
 iterated over twice, once during this invocation, and again when needing to cancel the 
 futures.  Because of that it is critical the <code>Iterable</code> provided returns the exact same 
 future contents at the time of invoking this call.  If that guarantee can not be provided, 
 you must specify <code>true</code> for the <code>copy</code> parameter.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>copy</code> - <code>true</code> to copy provided futures to avoid</dd>
<dd><code>futures</code> - Futures to be monitored and canceled on error</dd>
<dd><code>interruptThread</code> - Valued passed in to interrupt thread when calling <code>Future.cancel(boolean)</code></dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>4.7.2</dd>
</dl>
</li>
</ul>
<a id="immediateResultFuture(java.lang.Object)">
<!--   -->
</a><a id="immediateResultFuture(T)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>immediateResultFuture</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;T&gt;&nbsp;immediateResultFuture&#8203;(T&nbsp;result)</pre>
<div class="block">Constructs a <a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future"><code>ListenableFuture</code></a> that has already had the provided result given to it.  
 Thus the resulting future can not error, block, or be canceled.  
 <p>
 If <code>null</code> is provided here the static instance of 
 <a href="ImmediateResultListenableFuture.html#NULL_RESULT"><code>ImmediateResultListenableFuture.NULL_RESULT</code></a> will be returned to reduce GC overhead.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - The result object type returned by the returned future</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>result</code> - result to be provided in .get() call</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Already satisfied future</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>1.2.0</dd>
</dl>
</li>
</ul>
<a id="immediateFailureFuture(java.lang.Throwable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>immediateFailureFuture</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;T&gt;&nbsp;immediateFailureFuture&#8203;(java.lang.Throwable&nbsp;failure)</pre>
<div class="block">Constructs a <a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future"><code>ListenableFuture</code></a> that has failed with the given failure.  Thus the 
 resulting future can not block, or be canceled.  Calls to <code>Future.get()</code> will 
 immediately throw an <code>ExecutionException</code>.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - The result object type returned by the returned future</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>failure</code> - to provide as cause for ExecutionException thrown from .get() call</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Already satisfied future</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>1.2.0</dd>
</dl>
</li>
</ul>
<a id="scheduleWhileTaskResultNull(org.threadly.concurrent.SubmitterScheduler,long,boolean,java.util.concurrent.Callable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>scheduleWhileTaskResultNull</h4>
<pre class="methodSignature">@Deprecated
public static&nbsp;&lt;T&gt;&nbsp;<a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;T&gt;&nbsp;scheduleWhileTaskResultNull&#8203;(<a href="../SubmitterScheduler.html" title="interface in org.threadly.concurrent">SubmitterScheduler</a>&nbsp;scheduler,
                                                                  long&nbsp;scheduleDelayMillis,
                                                                  boolean&nbsp;firstRunAsync,
                                                                  java.util.concurrent.Callable&lt;? extends T&gt;&nbsp;task)</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Please use <a href="#scheduleWhile(org.threadly.concurrent.SubmitterScheduler,long,boolean,java.util.concurrent.Callable,java.util.function.Predicate)"><code>scheduleWhile(SubmitterScheduler, long, boolean, Callable, Predicate)</code></a></div>
</div>
<div class="block">Will continue to schedule the provided task as long as the task is returning a <code>null</code> 
 result.  This can be a good way to implement retry logic where a result ultimately needs to be 
 communicated through a future.  
 <p>
 The returned future will only complete with a result once the provided task returns a 
 non-null result.  Canceling the returned future will prevent future executions from being 
 attempted.  Canceling with an interrupt will transmit the interrupt to the running task if it 
 is currently running.  
 <p>
 The first execution will either be immediately executed in thread or submitted for immediate 
 execution on the provided scheduler (depending on <code>firstRunAsync</code> parameter).  Once 
 this execution completes, if the result is <code>null</code> then the task will be rescheduled for 
 execution.  If non-null then the result will be able to be retrieved from the returned 
 <a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future"><code>ListenableFuture</code></a>.  
 <p>
 If you want to ensure this does not reschedule forever consider using 
 <a href="#scheduleWhileTaskResultNull(org.threadly.concurrent.SubmitterScheduler,long,boolean,java.util.concurrent.Callable,long)"><code>scheduleWhileTaskResultNull(SubmitterScheduler, long, boolean, Callable, long)</code></a>.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - The result object type returned by the task and provided by the future</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>scheduler</code> - Scheduler to schedule out task executions</dd>
<dd><code>scheduleDelayMillis</code> - Delay in milliseconds to schedule out future attempts</dd>
<dd><code>firstRunAsync</code> - <code>False</code> to run first try on invoking thread, <code>true</code> to submit on scheduler</dd>
<dd><code>task</code> - Task which will provide result, or <code>null</code> to reschedule itself again</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Future that will resolve with non-null result from task</dd>
</dl>
</li>
</ul>
<a id="scheduleWhileTaskResultNull(org.threadly.concurrent.SubmitterScheduler,long,boolean,java.util.concurrent.Callable,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>scheduleWhileTaskResultNull</h4>
<pre class="methodSignature">@Deprecated
public static&nbsp;&lt;T&gt;&nbsp;<a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;T&gt;&nbsp;scheduleWhileTaskResultNull&#8203;(<a href="../SubmitterScheduler.html" title="interface in org.threadly.concurrent">SubmitterScheduler</a>&nbsp;scheduler,
                                                                  long&nbsp;scheduleDelayMillis,
                                                                  boolean&nbsp;firstRunAsync,
                                                                  java.util.concurrent.Callable&lt;? extends T&gt;&nbsp;task,
                                                                  long&nbsp;timeoutMillis)</pre>
<div class="deprecationBlock"><span class="deprecatedLabel">Deprecated.</span>
<div class="deprecationComment">Please use with a simple null checking Predicate
               <a href="#scheduleWhile(org.threadly.concurrent.SubmitterScheduler,long,boolean,java.util.concurrent.Callable,java.util.function.Predicate,long,boolean)"><code>scheduleWhile(SubmitterScheduler, long, boolean, Callable, Predicate, long, boolean)</code></a></div>
</div>
<div class="block">Will continue to schedule the provided task as long as the task is returning a <code>null</code> 
 result.  This can be a good way to implement retry logic where a result ultimately needs to be 
 communicated through a future.  
 <p>
 The returned future will only complete with a result once the provided task returns a non-null 
 result, or until the provided timeout is reached.  If the timeout is reached then the task 
 wont be rescheduled.  Instead the future will be resolved with a <code>null</code> result.  Even if 
 only 1 millisecond before timeout, the entire <code>rescheduleDelayMillis</code> will be provided 
 for the next attempt's scheduled delay.  Canceling the returned future will prevent future 
 executions from being attempted.  Canceling with an interrupt will transmit the interrupt to 
 the running task if it is currently running.  
 <p>
 The first execution will either be immediately executed in thread or submitted for immediate 
 execution on the provided scheduler (depending on <code>firstRunAsync</code> parameter).  Once 
 this execution completes, if the result is <code>null</code> then the task will be rescheduled for 
 execution.  If non-null then the result will be able to be retrieved from the returned 
 <a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future"><code>ListenableFuture</code></a>.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - The result object type returned by the task and provided by the future</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>scheduler</code> - Scheduler to schedule out task executions</dd>
<dd><code>scheduleDelayMillis</code> - Delay in milliseconds to schedule out future attempts</dd>
<dd><code>firstRunAsync</code> - <code>False</code> to run first try on invoking thread, <code>true</code> to submit on scheduler</dd>
<dd><code>task</code> - Task which will provide result, or <code>null</code> to reschedule itself again</dd>
<dd><code>timeoutMillis</code> - Timeout in milliseconds task wont be rescheduled and instead just finish with <code>null</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Future that will resolve with non-null result from task</dd>
</dl>
</li>
</ul>
<a id="scheduleWhile(org.threadly.concurrent.SubmitterScheduler,long,boolean,java.lang.Runnable,java.util.function.Supplier)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>scheduleWhile</h4>
<pre class="methodSignature">public static&nbsp;<a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;?&gt;&nbsp;scheduleWhile&#8203;(<a href="../SubmitterScheduler.html" title="interface in org.threadly.concurrent">SubmitterScheduler</a>&nbsp;scheduler,
                                                long&nbsp;scheduleDelayMillis,
                                                boolean&nbsp;firstRunAsync,
                                                java.lang.Runnable&nbsp;task,
                                                java.util.function.Supplier&lt;java.lang.Boolean&gt;&nbsp;loopTest)</pre>
<div class="block">Executes a task until the provided supplier returns <code>false</code>.  This can be a good way to 
 implement retry logic where there completion (but not result) needs to be communicated.  If 
 a result is needed please see 
 <a href="#scheduleWhile(org.threadly.concurrent.SubmitterScheduler,long,boolean,java.util.concurrent.Callable,java.util.function.Predicate)"><code>scheduleWhile(SubmitterScheduler, long, boolean, Callable, Predicate)</code></a>.
 <p>
 The returned future will only provide a result once the looping of the task has completed.  
 Canceling the returned future will prevent future executions from being attempted.  Canceling 
 with an interrupt will transmit the interrupt to the running task if it is currently running.  
 <p>
 The first execution will either be immediately executed in thread or submitted for immediate 
 execution on the provided scheduler (depending on <code>firstRunAsync</code> parameter).  Once 
 this execution completes the result will be provided to the <code>Supplier</code> to determine if 
 another schedule should occur to re-run the task.  
 <p>
 If you want to ensure this does not reschedule forever consider using 
 <a href="#scheduleWhile(org.threadly.concurrent.SubmitterScheduler,long,boolean,java.lang.Runnable,java.util.function.Supplier,long)"><code>scheduleWhile(SubmitterScheduler, long, boolean, Runnable, Supplier, long)</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>scheduler</code> - Scheduler to schedule out task executions</dd>
<dd><code>scheduleDelayMillis</code> - Delay after predicate indicating to loop again before re-executed</dd>
<dd><code>firstRunAsync</code> - <code>False</code> to run first try on invoking thread, <code>true</code> to submit on scheduler</dd>
<dd><code>task</code> - Task to execute as long as test returns <code>true</code></dd>
<dd><code>loopTest</code> - Test to see if scheduled loop should continue</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Future that will resolve once returned <code>Supplier</code> returns <code>false</code></dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>5.0</dd>
</dl>
</li>
</ul>
<a id="scheduleWhile(org.threadly.concurrent.SubmitterScheduler,long,boolean,java.lang.Runnable,java.util.function.Supplier,long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>scheduleWhile</h4>
<pre class="methodSignature">public static&nbsp;<a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;?&gt;&nbsp;scheduleWhile&#8203;(<a href="../SubmitterScheduler.html" title="interface in org.threadly.concurrent">SubmitterScheduler</a>&nbsp;scheduler,
                                                long&nbsp;scheduleDelayMillis,
                                                boolean&nbsp;firstRunAsync,
                                                java.lang.Runnable&nbsp;task,
                                                java.util.function.Supplier&lt;java.lang.Boolean&gt;&nbsp;loopTest,
                                                long&nbsp;timeoutMillis)</pre>
<div class="block">Executes a task, checking the result from the task to see if it needs to reschedule the task 
 again.  This can be a good way to implement retry logic where a result ultimately needs to be 
 communicated through a future.  
 <p>
 The returned future will only provide a result once the looping of the task has completed, or 
 until the provided timeout is reached.  If the timeout is reached then the task wont be 
 rescheduled.  Even if only 1 millisecond before timeout, the entire 
 <code>rescheduleDelayMillis</code> will be provided for the next attempt's scheduled delay.  On a 
 timeout, if <code>true</code> was provided for <code>timeoutProvideLastValue</code> then the future 
 will be resolved with the last result provided.  If <code>false</code> was provided then the 
 future will complete in an error state, the cause of which being a <code>TimeoutException</code>.
 Canceling the returned future will prevent future executions from being attempted.  Canceling 
 with an interrupt will transmit the interrupt to the running task if it is currently running.  
 <p>
 The first execution will either be immediately executed in thread or submitted for immediate 
 execution on the provided scheduler (depending on <code>firstRunAsync</code> parameter).  Once 
 this execution completes the result will be provided to the <code>Supplier</code> to determine if 
 another schedule should occur to re-run the task.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>scheduler</code> - Scheduler to schedule out task executions</dd>
<dd><code>scheduleDelayMillis</code> - Delay after predicate indicating to loop again before re-executed</dd>
<dd><code>firstRunAsync</code> - <code>False</code> to run first try on invoking thread, <code>true</code> to submit on scheduler</dd>
<dd><code>task</code> - Task to execute as long as test returns <code>true</code></dd>
<dd><code>loopTest</code> - Test to see if scheduled loop should continue</dd>
<dd><code>timeoutMillis</code> - If greater than zero, wont reschedule and instead will just return the last result</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Future that will resolve once returned <code>Supplier</code> returns <code>false</code></dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>5.0</dd>
</dl>
</li>
</ul>
<a id="scheduleWhile(org.threadly.concurrent.SubmitterScheduler,long,boolean,java.util.concurrent.Callable,java.util.function.Predicate)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>scheduleWhile</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;T&gt;&nbsp;scheduleWhile&#8203;(<a href="../SubmitterScheduler.html" title="interface in org.threadly.concurrent">SubmitterScheduler</a>&nbsp;scheduler,
                                                    long&nbsp;scheduleDelayMillis,
                                                    boolean&nbsp;firstRunAsync,
                                                    java.util.concurrent.Callable&lt;? extends T&gt;&nbsp;task,
                                                    java.util.function.Predicate&lt;? super T&gt;&nbsp;loopTest)</pre>
<div class="block">Executes a task, checking the result from the task to see if it needs to reschedule the task 
 again.  This can be a good way to implement retry logic where a result ultimately needs to be 
 communicated through a future.  
 <p>
 The returned future will only provide a result once the looping of the task has completed.  
 Canceling the returned future will prevent future executions from being attempted.  Canceling 
 with an interrupt will transmit the interrupt to the running task if it is currently running.  
 <p>
 The first execution will either be immediately executed in thread or submitted for immediate 
 execution on the provided scheduler (depending on <code>firstRunAsync</code> parameter).  Once 
 this execution completes the result will be provided to the <code>Predicate</code> to determine if 
 another schedule should occur to re-run the task.  
 <p>
 If you want to ensure this does not reschedule forever consider using 
 <a href="#scheduleWhile(org.threadly.concurrent.SubmitterScheduler,long,boolean,java.util.concurrent.Callable,java.util.function.Predicate,long,boolean)"><code>scheduleWhile(SubmitterScheduler, long, boolean, Callable, Predicate, long, boolean)</code></a>.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - The result object type returned by the task and provided by the future</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>scheduler</code> - Scheduler to schedule out task executions</dd>
<dd><code>scheduleDelayMillis</code> - Delay after predicate indicating to loop again before re-executed</dd>
<dd><code>firstRunAsync</code> - <code>False</code> to run first try on invoking thread, <code>true</code> to submit on scheduler</dd>
<dd><code>task</code> - Task which will provide result to compare in provided <code>Predicate</code></dd>
<dd><code>loopTest</code> - Test for result to see if scheduled loop should continue</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Future that will resolve once returned <code>Predicate</code> returns <code>false</code></dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>5.0</dd>
</dl>
</li>
</ul>
<a id="scheduleWhile(org.threadly.concurrent.SubmitterScheduler,long,boolean,java.util.concurrent.Callable,java.util.function.Predicate,long,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>scheduleWhile</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;T&gt;&nbsp;scheduleWhile&#8203;(<a href="../SubmitterScheduler.html" title="interface in org.threadly.concurrent">SubmitterScheduler</a>&nbsp;scheduler,
                                                    long&nbsp;scheduleDelayMillis,
                                                    boolean&nbsp;firstRunAsync,
                                                    java.util.concurrent.Callable&lt;? extends T&gt;&nbsp;task,
                                                    java.util.function.Predicate&lt;? super T&gt;&nbsp;loopTest,
                                                    long&nbsp;timeoutMillis,
                                                    boolean&nbsp;timeoutProvideLastValue)</pre>
<div class="block">Executes a task, checking the result from the task to see if it needs to reschedule the task 
 again.  This can be a good way to implement retry logic where a result ultimately needs to be 
 communicated through a future.  
 <p>
 The returned future will only provide a result once the looping of the task has completed, or 
 until the provided timeout is reached.  If the timeout is reached then the task wont be 
 rescheduled.  Even if only 1 millisecond before timeout, the entire 
 <code>rescheduleDelayMillis</code> will be provided for the next attempt's scheduled delay.  On a 
 timeout, if <code>true</code> was provided for <code>timeoutProvideLastValue</code> then the future 
 will be resolved with the last result provided.  If <code>false</code> was provided then the 
 future will complete in an error state, the cause of which being a <code>TimeoutException</code>.
 Canceling the returned future will prevent future executions from being attempted.  Canceling 
 with an interrupt will transmit the interrupt to the running task if it is currently running.  
 <p>
 The first execution will either be immediately executed in thread or submitted for immediate 
 execution on the provided scheduler (depending on <code>firstRunAsync</code> parameter).  Once 
 this execution completes the result will be provided to the <code>Predicate</code> to determine if 
 another schedule should occur to re-run the task.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - The result object type returned by the task and provided by the future</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>scheduler</code> - Scheduler to schedule out task executions</dd>
<dd><code>scheduleDelayMillis</code> - Delay after predicate indicating to loop again before re-executed</dd>
<dd><code>firstRunAsync</code> - <code>False</code> to run first try on invoking thread, <code>true</code> to submit on scheduler</dd>
<dd><code>task</code> - Task which will provide result to compare in provided <code>Predicate</code></dd>
<dd><code>loopTest</code> - Test for result to see if scheduled loop should continue</dd>
<dd><code>timeoutMillis</code> - If greater than zero, wont reschedule and instead will just return the last result</dd>
<dd><code>timeoutProvideLastValue</code> - On timeout <code>false</code> will complete with a TimeoutException, 
                                  <code>true</code> completes with the last result</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Future that will resolve once returned <code>Predicate</code> returns <code>false</code> or timeout is reached</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>5.0</dd>
</dl>
</li>
</ul>
<a id="scheduleWhile(org.threadly.concurrent.SubmitterScheduler,long,org.threadly.concurrent.future.ListenableFuture,java.util.concurrent.Callable,java.util.function.Predicate)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>scheduleWhile</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;T&gt;&nbsp;scheduleWhile&#8203;(<a href="../SubmitterScheduler.html" title="interface in org.threadly.concurrent">SubmitterScheduler</a>&nbsp;scheduler,
                                                    long&nbsp;scheduleDelayMillis,
                                                    <a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;? extends T&gt;&nbsp;startingFuture,
                                                    java.util.concurrent.Callable&lt;? extends T&gt;&nbsp;task,
                                                    java.util.function.Predicate&lt;? super T&gt;&nbsp;loopTest)</pre>
<div class="block">Executes a task, checking the result from the task to see if it needs to reschedule the task 
 again.  This can be a good way to implement retry logic where a result ultimately needs to be 
 communicated through a future.  
 <p>
 The returned future will only provide a result once the looping of the task has completed.  
 Canceling the returned future will prevent future executions from being attempted.  Canceling 
 with an interrupt will transmit the interrupt to the running task if it is currently running.  
 <p>
 The first execution will happen as soon as the provided <code>startingFuture</code> completes.  
 <p>
 If you want to ensure this does not reschedule forever consider using 
 <a href="#scheduleWhile(org.threadly.concurrent.SubmitterScheduler,long,org.threadly.concurrent.future.ListenableFuture,java.util.concurrent.Callable,java.util.function.Predicate,long,boolean)"><code>scheduleWhile(SubmitterScheduler, long, ListenableFuture, Callable, Predicate, long, boolean)</code></a>.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - The result object type returned by the task and provided by the future</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>scheduler</code> - Scheduler to schedule out task executions</dd>
<dd><code>scheduleDelayMillis</code> - Delay after predicate indicating to loop again before re-executed</dd>
<dd><code>startingFuture</code> - Future to use for first result to test for loop</dd>
<dd><code>task</code> - Task which will provide result to compare in provided <code>Predicate</code></dd>
<dd><code>loopTest</code> - Test for result to see if scheduled loop should continue</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Future that will resolve once returned <code>Predicate</code> returns <code>false</code></dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>5.0</dd>
</dl>
</li>
</ul>
<a id="scheduleWhile(org.threadly.concurrent.SubmitterScheduler,long,org.threadly.concurrent.future.ListenableFuture,java.util.concurrent.Callable,java.util.function.Predicate,long,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>scheduleWhile</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;T&gt;&nbsp;scheduleWhile&#8203;(<a href="../SubmitterScheduler.html" title="interface in org.threadly.concurrent">SubmitterScheduler</a>&nbsp;scheduler,
                                                    long&nbsp;scheduleDelayMillis,
                                                    <a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;? extends T&gt;&nbsp;startingFuture,
                                                    java.util.concurrent.Callable&lt;? extends T&gt;&nbsp;task,
                                                    java.util.function.Predicate&lt;? super T&gt;&nbsp;loopTest,
                                                    long&nbsp;timeoutMillis,
                                                    boolean&nbsp;timeoutProvideLastValue)</pre>
<div class="block">Executes a task, checking the result from the task to see if it needs to reschedule the task 
 again.  This can be a good way to implement retry logic where a result ultimately needs to be 
 communicated through a future.  
 <p>
 The returned future will only provide a result once the looping of the task has completed, or 
 until the provided timeout is reached.  If the timeout is reached then the task wont be 
 rescheduled.  Even if only 1 millisecond before timeout, the entire 
 <code>rescheduleDelayMillis</code> will be provided for the next attempt's scheduled delay.  On a 
 timeout, if <code>true</code> was provided for <code>timeoutProvideLastValue</code> then the future 
 will be resolved with the last result provided.  If <code>false</code> was provided then the 
 future will complete in an error state, the cause of which being a <code>TimeoutException</code>.
 Canceling the returned future will prevent future executions from being attempted.  Canceling 
 with an interrupt will transmit the interrupt to the running task if it is currently running.  
 <p>
 The first execution will happen as soon as the provided <code>startingFuture</code> completes.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - The result object type returned by the task and provided by the future</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>scheduler</code> - Scheduler to schedule out task executions</dd>
<dd><code>scheduleDelayMillis</code> - Delay after predicate indicating to loop again before re-executed</dd>
<dd><code>startingFuture</code> - Future to use for first result to test for loop</dd>
<dd><code>task</code> - Task which will provide result to compare in provided <code>Predicate</code></dd>
<dd><code>loopTest</code> - Test for result to see if scheduled loop should continue</dd>
<dd><code>timeoutMillis</code> - If greater than zero, wont reschedule and instead will just return the last result</dd>
<dd><code>timeoutProvideLastValue</code> - On timeout <code>false</code> will complete with a TimeoutException, 
                                  <code>true</code> completes with the last result</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Future that will resolve once returned <code>Predicate</code> returns <code>false</code></dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>5.0</dd>
</dl>
</li>
</ul>
<a id="executeWhile(java.util.concurrent.Callable,java.util.function.Predicate)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>executeWhile</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;T&gt;&nbsp;executeWhile&#8203;(java.util.concurrent.Callable&lt;? extends <a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;? extends T&gt;&gt;&nbsp;asyncTask,
                                                   java.util.function.Predicate&lt;? super T&gt;&nbsp;loopTest)</pre>
<div class="block">Similar to <a href="#scheduleWhile(org.threadly.concurrent.SubmitterScheduler,long,boolean,java.util.concurrent.Callable,java.util.function.Predicate)"><code>scheduleWhile(SubmitterScheduler, long, boolean, Callable, Predicate)</code></a> 
 except that no executor is needed because the callable instead will return a future from the 
 provided async submission (which may be a scheduled task or otherwise).
 <p>
 In the end this is just another way to have a loop of async actions, checking results as they 
 are provided but not resolving the returned future till the async action completes.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - The result object type returned by the task and provided by the future</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>asyncTask</code> - Callable to produce a <a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future"><code>ListenableFuture</code></a> for when a result is ready</dd>
<dd><code>loopTest</code> - The test to check the ready result to see if we need to keep looping</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Future that will resolve once returned <code>Predicate</code> returns <code>false</code></dd>
</dl>
</li>
</ul>
<a id="executeWhile(java.util.concurrent.Callable,java.util.function.Predicate,long,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>executeWhile</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;T&gt;&nbsp;executeWhile&#8203;(java.util.concurrent.Callable&lt;? extends <a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;? extends T&gt;&gt;&nbsp;asyncTask,
                                                   java.util.function.Predicate&lt;? super T&gt;&nbsp;loopTest,
                                                   long&nbsp;timeoutMillis,
                                                   boolean&nbsp;timeoutProvideLastValue)</pre>
<div class="block">Similar to <a href="#scheduleWhile(org.threadly.concurrent.SubmitterScheduler,long,boolean,java.util.concurrent.Callable,java.util.function.Predicate,long,boolean)"><code>scheduleWhile(SubmitterScheduler, long, boolean, Callable, Predicate, long, boolean)</code></a> 
 except that no executor is needed because the callable instead will return a future from the 
 provided async submission (which may be a scheduled task or otherwise).
 <p>
 In the end this is just another way to have a loop of async actions, checking results as they 
 are provided but not resolving the returned future till the async action completes.  On a 
 timeout, if <code>true</code> was provided for <code>timeoutProvideLastValue</code> then the future 
 will be resolved with the last result provided.  If <code>false</code> was provided then the 
 future will complete in an error state, the cause of which being a <code>TimeoutException</code>.
 Canceling the returned future will prevent future executions from being attempted.  Canceling 
 with an interrupt will transmit the interrupt to the running task if it is currently running.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - The result object type returned by the task and provided by the future</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>asyncTask</code> - Callable to produce a <a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future"><code>ListenableFuture</code></a> for when a result is ready</dd>
<dd><code>loopTest</code> - The test to check the ready result to see if we need to keep looping</dd>
<dd><code>timeoutMillis</code> - If greater than zero, wont reschedule and instead will just return the last result</dd>
<dd><code>timeoutProvideLastValue</code> - On timeout <code>false</code> will complete with a TimeoutException, 
                                  <code>true</code> completes with the last result</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Future that will resolve once returned <code>Predicate</code> returns <code>false</code></dd>
</dl>
</li>
</ul>
<a id="executeWhile(org.threadly.concurrent.future.ListenableFuture,java.util.concurrent.Callable,java.util.function.Predicate)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>executeWhile</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;T&gt;&nbsp;executeWhile&#8203;(<a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;? extends T&gt;&nbsp;startingFuture,
                                                   java.util.concurrent.Callable&lt;? extends <a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;? extends T&gt;&gt;&nbsp;asyncTask,
                                                   java.util.function.Predicate&lt;? super T&gt;&nbsp;loopTest)</pre>
<div class="block">Similar to <a href="#scheduleWhile(org.threadly.concurrent.SubmitterScheduler,long,org.threadly.concurrent.future.ListenableFuture,java.util.concurrent.Callable,java.util.function.Predicate)"><code>scheduleWhile(SubmitterScheduler, long, ListenableFuture, Callable, Predicate)</code></a> 
 except that no executor is needed because the callable instead will return a future from the 
 provided async submission (which may be a scheduled task or otherwise).
 <p>
 In the end this is just another way to have a loop of async actions, checking results as they 
 are provided but not resolving the returned future till the async action completes.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - The result object type returned by the task and provided by the future</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>startingFuture</code> - Future to use for first result to test for loop</dd>
<dd><code>asyncTask</code> - Callable to produce a <a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future"><code>ListenableFuture</code></a> for when a result is ready</dd>
<dd><code>loopTest</code> - The test to check the ready result to see if we need to keep looping</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Future that will resolve once returned <code>Predicate</code> returns <code>false</code></dd>
</dl>
</li>
</ul>
<a id="executeWhile(org.threadly.concurrent.future.ListenableFuture,java.util.concurrent.Callable,java.util.function.Predicate,long,boolean)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>executeWhile</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;T&gt;&nbsp;executeWhile&#8203;(<a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;? extends T&gt;&nbsp;startingFuture,
                                                   java.util.concurrent.Callable&lt;? extends <a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future">ListenableFuture</a>&lt;? extends T&gt;&gt;&nbsp;asyncTask,
                                                   java.util.function.Predicate&lt;? super T&gt;&nbsp;loopTest,
                                                   long&nbsp;timeoutMillis,
                                                   boolean&nbsp;lastValueOnTimeout)</pre>
<div class="block">Similar to <a href="#scheduleWhile(org.threadly.concurrent.SubmitterScheduler,long,org.threadly.concurrent.future.ListenableFuture,java.util.concurrent.Callable,java.util.function.Predicate,long,boolean)"><code>scheduleWhile(SubmitterScheduler, long, ListenableFuture, Callable, Predicate, long, boolean)</code></a> 
 except that no executor is needed because the callable instead will return a future from the 
 provided async submission (which may be a scheduled task or otherwise).
 <p>
 In the end this is just another way to have a loop of async actions, checking results as they 
 are provided but not resolving the returned future till the async action completes.  On a 
 timeout, if <code>true</code> was provided for <code>timeoutProvideLastValue</code> then the future 
 will be resolved with the last result provided.  If <code>false</code> was provided then the 
 future will complete in an error state, the cause of which being a <code>TimeoutException</code>.
 Canceling the returned future will prevent future executions from being attempted.  Canceling 
 with an interrupt will transmit the interrupt to the running task if it is currently running.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - The result object type returned by the task and provided by the future</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>startingFuture</code> - Future to use for first result to test for loop</dd>
<dd><code>asyncTask</code> - Callable to produce a <a href="ListenableFuture.html" title="interface in org.threadly.concurrent.future"><code>ListenableFuture</code></a> for when a result is ready</dd>
<dd><code>loopTest</code> - The test to check the ready result to see if we need to keep looping</dd>
<dd><code>timeoutMillis</code> - If greater than zero, wont reschedule and instead will just return the last result</dd>
<dd><code>lastValueOnTimeout</code> - On timeout <code>false</code> will complete with a TimeoutException, 
                               <code>true</code> completes with the last result</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Future that will resolve once returned <code>Predicate</code> returns <code>false</code></dd>
</dl>
</li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
</div>
</main>
<!-- ========= END OF CLASS DATA ========= -->
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
</footer>
</body>
</html>
